# Câu hỏi phỏng vấn Java - Đáp án

Nếu bạn đang chuẩn bị cho phỏng vấn Java, dưới đây là 100+ câu hỏi phỏng vấn Java chính cùng với câu trả lời dành riêng cho bạn, bao gồm một số câu hỏi khó và câu trả lời.

### Mục lục

| STT | Câu hỏi                                                                                                                                                                                                                                                                                                             |
| --- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 51  | [Vui lòng giải thích JAVA - Cấu trúc dữ liệu?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#51please-explain-java---data-structures)                                                                                                                                                    |
| 52  | [Những cấu trúc dữ liệu quen thuộc nào bạn đã sử dụng trong java?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#52-what-are-the-familiar-data-structures-you-used-in-java)                                                                                                                 |
| 53  | [Hashmap hoạt động như thế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#53how-does-hashmap-work)                                                                                                                                                                                    |
| 54  | [Giải thích hashmap đồng thời? Và tại sao chúng ta cần một hashmap đồng thời?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#54explain-concurrent-hashmap-and-why-do-we-need-a-concurrent-hashmap)                                                                                         |
| 55  | [Sự khác biệt giữa docker và máy ảo là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#55what-is-the-difference-between-docker-vs-virtual-machine)                                                                                                              |
| 56  | [Khi bạn thực hiện microservices, chúng ta có nhiều microservices và có những lợi ích và nhược điểm khác nhau?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#56when-you-do-the-microservices-we-have-multiple-microservices-and-there-are-difference-pros-and-cons)                        |
| 57  | [Trạng thái đóng là gì, trạng thái mở là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#57what-is-closed-state-open-state)                                                                                                                                                               |
| 58  | [Hystrix là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#58what-is-hystrix)                                                                                                                                                                                                |
| 59  | [Cho tôi biết sự khác biệt giữa khóa băm và khóa sắp xếp trong dynamodb?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#59tell-me-the-difference-between-hash-key-and-sort-key-in-dynamodb)                                                                                              |
| 60  | [Sự khác biệt giữa danh sách và bảng băm là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#60what-is-the-difference-between-list-and-hash-table)                                                                                                                          |
| 61  | [Bạn đang cố gắng lưu trữ thông tin của mọi người trong một bảng băm. Bạn sẽ thiết kế khóa của mình như thế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#61youre-trying-to-store-peoples-info-in-a-hash-table-how-would-you-design-your-key)                                                           |
| 62  | [Từ khóa synchronized là gì và có những cách sử dụng khác nhau nào cho từ khóa synchronized?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#62-what-is-the-synchronized-keyword-and-what-are-the-different-ways-to-use-synchronized-keywords)                                   |
| 63  | [Khối synchronized là gì? Sự khác biệt giữa khối synchronized và phương thức synchronized là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#63what-is-a-synchronized-block-what-is-the-difference-between-synchronized-block-and-synchronized-method)                 |
| 64  | [Giải thích về các bộ tích lũy đồng thời? Và tính đồng thời trong java?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#64-explain-concurrent-accumulators--and-concurrency-in-java)                                                                                                             |
| 65  | [Các bộ tích lũy đồng thời trong java?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#65concurrent-accumulators-in-java)                                                                                                                                                                |
| 66  | [Sự khác biệt giữa lưu trữ nóng và lưu trữ lạnh là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#66-difference-between-hot-storage-vs-cold-storage)                                                                                                                                 |
| 67  | [Lớp trừu tượng trong java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#67-what-is-an-abstract-class-in-java)                                                                                                                                                           |
| 68  | [Giao diện là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#68-what-is-the-interface)                                                                                                                                                                                   |
| 69  | [Sử dụng của equals trong JAVA là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#69-use-of-equals-in-java)                                                                                                                                                                                   |
| 70  | [EKS là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#70-what-is-eks)                                                                                                                                                                                                       |
| 71  | [EKS hoạt động như thế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#71how-does-eks-work)                                                                                                                                                                                            |
| 72  | [Bạn chạy lệnh gì trên EKS?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#72what-commands-do-you-run-eks)                                                                                                                                                                      |
| 73  | [Phiên bản hóa là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#73what-is-versioning)                                                                                                                                                                                          |
| 74  | [Bạn hiểu gì về vòng đời của một luồng?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#74-what-do-you-mean-by-the-life-cycle-of-a-thread)                                                                                                                                 |
| 75  | ["Phiên bản hóa đối tượng" có nghĩa là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#75-what-does-versioning-of-objects-mean)                                                                                                                                                   |
| 76  | [Sự khác biệt giữa rest và soap là gì? Đâu là an toàn hơn: rest hay soap?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#76-difference-between-rest-and-soap-which-is-more-secure-rest-or-soap)                                                                                       |
| 77  | [Sự khác biệt giữa compute và Kubernetes engine là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#77-difference-between-compute-and-kubernetes-engine)                                                                                                                             |
| 78  | [Sự khác biệt giữa @component & @bean là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#78-difference-between-component--bean)                                                                                                                                                      |
| 79  | [Cho tôi biết lợi ích của việc sử dụng biểu thức lambda Java8 là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#79-tell-me-the-benefit-of-using-java8-lambda-expressions)                                                                                                                   |
| 80  | [Predicate trong java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#80-what-is-a-predicate-in-java)                                                                                                                                                                       |
| 81  | [Cách tạo một lớp singleton?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#81-how-to-create-a-singleton-class)                                                                                                                                                               |
| 82  | [Bạn có biết về giao diện marker không?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#82-do-you-know-the-marker-interface)                                                                                                                                                             |
| 83  | [Khi nào bạn sử dụng serialization?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#83-when-do-you-use-serialization)                                                                                                                                                                   |
| 84  | [Materialized view trong java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#84-what-is-a-materialized-view-in-java)                                                                                                                                                       |
| 85  | [NFR là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#85-what-is-nfr)                                                                                                                                                                                                       |
| 86  | [Khả năng phục hồi trong java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#86-what-is-the-resiliency-in-java)                                                                                                                                                                 |
| 87  | [Giải thích về mẫu circuit breaker?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#87-explain-the-circuit-breaker-pattern)                                                                                                                                                       |
| 88  | [Trong java, bạn đã sử dụng bất kỳ mẫu thiết kế nào chưa?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#88-in-java-have-you-used-any-design-patterns)                                                                                                                                           |
| 89  | [Có những cách nào để tạo một luồng?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#89-what-are-the-different-ways-to-create-a-thread)                                                                                                                                 |
| 90  | [Spring Annotation là gì? Vui lòng cho ví dụ?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#90-what-is-spring-annotation-please-give-examples-too)                                                                                                                        |
| 91  | [Splunk là gì? Dữ liệu sẽ đến Splunk như thế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#91-what-is-splunk-how-will-logs-come-in-splunk)                                                                                                                                      |
| 92  | [Mẫu Resiliency trong Java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#92-what-is-the-resiliency-pattern-in-java)                                                                                                                                                 |
| 93  | [Mẫu circuit breaker là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#93-what-is-the-circuit-breaker-pattern)                                                                                                                                                       |
| 94  | [Hibernate criteria builder là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#94-what-is-a-hibernate-criteria-builder)                                                                                                                                                     |
| 95  | [Sự khác biệt giữa put và patch là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#95-what-is-the-difference-between-put-and-patch)                                                                                                                                     |
| 96  | [Java Streams là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#96-what-are-java-streams)                                                                                                                                                                                   |
| 97  | [Tại sao các biến trong giao diện là public, static, final?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#97-why-variables-in-interface-are-public-static-final)                                                                                                                       |
| 98  | [Tại sao các biến trong giao diện không cần khai báo trong các lớp thực thi?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#98-why-variables-in-interface-dont-need-to-declare-in-implementing-classes)                                                                              |
| 99  | [Điều gì sẽ xảy ra nếu bạn đặt câu lệnh return hoặc System.exit() trong khối try hoặc catch? Khối finally có thực thi không?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#99-what-will-happen-if-you-put-return-statement-or-systemexit--on-try-or-catch-block-will-finally-block-execute) |
| 100 | [Bạn có thể ghi đè một phương thức private hoặc static trong Java không?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#100-can-you-override-a-private-or-static-method-in-java)                                                                                                                      |
| 101 | [Chương trình Java sau đây in ra cái gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#101-what-does-the-following-java-program-print)                                                                                                                                        |

### 51. Vui lòng giải thích JAVA - Cấu trúc dữ liệu?

Cấu trúc dữ liệu là một cách tổ chức dữ liệu trong máy tính để có thể sử dụng hiệu quả. Khi chúng ta nghĩ về cấu trúc dữ liệu, thường có bốn dạng:

- Tuyến tính: mảng, danh sách.
- Cây: nhị phân, heap, phân vùng không gian, v.v.
- Băm: bảng băm phân tán, cây băm, v.v.
- Đồ thị: quyết định, có hướng, không chu trình, v.v.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 52. Những cấu trúc dữ liệu quen thuộc nào bạn đã sử dụng trong java?

Cấu trúc dữ liệu là một phương tiện chuyên biệt để tổ chức và lưu trữ dữ liệu trong máy tính theo cách mà chúng ta có thể thực hiện các thao tác trên dữ liệu đã lưu trữ một cách hiệu quả hơn. Tôi đã sử dụng mảng, bảng băm, danh sách liên kết và ngăn xếp.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 53. Hashmap hoạt động như thế nào?

HashMap là một phần của framework collection trong Java. Nó sử dụng một kỹ thuật gọi là Hashing. Nó triển khai giao diện bản đồ. Nó lưu trữ dữ liệu dưới dạng cặp Khóa và Giá trị. HashMap chứa một mảng các nút, và nút được đại diện dưới dạng một lớp. Nó sử dụng cấu trúc dữ liệu mảng và LinkedList bên trong để lưu trữ Khóa và Giá trị. Có bốn trường trong HashMap.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 54. Giải thích hashmap đồng thời? Và tại sao chúng ta cần một hashmap đồng thời?

Nó cho phép truy cập đồng thời vào bản đồ. Một phần của bản đồ gọi là Segment (cấu trúc dữ liệu nội bộ) chỉ bị khóa khi thêm hoặc cập nhật bản đồ. Vì vậy, ConcurrentHashMap cho phép các luồng đồng thời đọc giá trị mà không cần khóa. Cấu trúc dữ liệu này được giới thiệu để cải thiện hiệu suất.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 55. Sự khác biệt giữa docker và máy ảo là gì?

**Docker** là công nghệ dựa trên container và các container chỉ là không gian người dùng của hệ điều hành. Nó được xây dựng để chạy các ứng dụng. Trong Docker, các container đang chạy chia sẻ kernel của hệ điều hành chủ.

**Máy ảo**, ngược lại, không dựa trên công nghệ container. Chúng được tạo thành từ không gian người dùng cộng với không gian kernel của một hệ điều hành. Dưới các máy ảo, phần cứng máy chủ được ảo hóa. Mỗi máy ảo có hệ điều hành (OS) và ứng dụng. Nó chia sẻ tài nguyên phần cứng từ máy chủ.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 56. Khi bạn thực hiện microservices, chúng ta có nhiều microservices và có những lợi ích và nhược điểm khác nhau?

Kiến trúc microservice là một phong cách phát triển phần mềm mà phân chia hệ thống thành các thành phần độc lập nhỏ hơn. Đây là một tập hợp các dịch vụ tự trị được thiết kế xung quanh một miền kinh doanh duy nhất. Những đơn vị riêng lẻ này có khả năng xử lý một phần chức năng của phần mềm. Dưới đây là những ưu điểm và nhược điểm của kiến trúc microservices:

**Ưu điểm:**

- Dễ dàng mở rộng
- Cải thiện mức độ chịu đựng
- Dễ hiểu mã nguồn
- Triển khai độc lập
- Phạm vi thử nghiệm

**Nhược điểm:**

- Giao tiếp phức tạp hơn
- Triển khai phức tạp
- Cần nhiều tài nguyên hơn
- Kiểm tra toàn cầu khó khăn
- Không được khuyến nghị cho ứng dụng nhỏ hơn

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 57. Trạng thái đóng là gì, trạng thái mở là gì?

**Trạng thái đóng:**
Trạng thái này ngụ ý rằng dịch vụ đang hoạt động và chạy (đúng cách). Sau đó, nếu số lượng phản hồi lỗi từ dịch vụ cần thiết vượt qua ngưỡng giới hạn, bộ ngắt mạch sẽ bị tripped (tức là: chuyển sang trạng thái mở).

**Trạng thái mở:**
Trong trạng thái này, bộ ngắt mạch sẽ không thực hiện các cuộc gọi từ xa. Vì các yêu cầu đã thất bại nhiều hơn ngưỡng, chúng ta sẽ biết rằng dịch vụ không hoạt động đúng cách. Thực tế, kết quả không cần phải là một thông báo lỗi 500 cho khách hàng. Với các bộ ngắt mạch, chúng tôi triển khai một phương thức dự phòng sẽ xử lý trường hợp dịch vụ cần thiết bị hỏng. Vì vậy, trong trạng thái mở, bộ ngắt mạch sẽ kích hoạt phương thức dự phòng. Sau một khoảng thời gian đáng kể, bộ ngắt mạch sẽ chuyển sang trạng thái nửa mở.

**Khi mạch mở, có thể làm gì?**

- Bạn có thể hiển thị thông báo lỗi
- Bạn có thể trả về dữ liệu đã lưu vào bộ nhớ cache

**Trạng thái nửa mở:**
Đây là một giai đoạn mà bộ ngắt mạch chuyển sang sau khi đã trải qua một thời gian trong trạng thái đóng. Trong giai đoạn này, bộ ngắt mạch thực hiện một cuộc gọi từ xa đến dịch vụ. Nếu yêu cầu thất bại, bộ ngắt mạch sẽ chuyển sang trạng thái mở. Nếu dịch vụ cung cấp phản hồi đúng, bộ ngắt mạch sẽ chuyển sang trạng thái đóng. Vì vậy, với một khoảng thời gian xác định, bộ ngắt mạch sẽ kiểm tra dịch vụ và quyết định trạng thái nào để chuyển sang.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 58. Hystrix là gì?

Hystrix là một thư viện java về độ trễ và khả năng chịu lỗi được thiết kế để cách ly các điểm truy cập đến các hệ thống từ xa, dịch vụ và thư viện bên thứ ba trong một môi trường phân tán. Nó giúp ngăn chặn sự cố lan truyền và cho phép khả năng phục hồi trong các hệ thống phân tán phức tạp nơi mà sự cố là không thể tránh khỏi.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 59. Cho tôi biết sự khác biệt giữa khóa băm và khóa sắp xếp trong dynamodb?

Khóa phân vùng − Khóa chính đơn giản này bao gồm một thuộc tính duy nhất được gọi là "khóa phân vùng". Nội bộ, DynamoDB sử dụng giá trị khóa làm đầu vào cho một hàm băm để xác định lưu trữ.

Khóa phân vùng và khóa sắp xếp − Khóa này, được gọi là "Khóa chính tổ hợp", bao gồm hai thuộc tính.

I. Khóa phân vùng
II. Khóa sắp xếp.

DynamoDB áp dụng thuộc tính đầu tiên cho một hàm băm và lưu trữ các mục với cùng một khóa phân vùng cùng nhau; với thứ tự của chúng được xác định bởi khóa sắp xếp. Các mục có thể chia sẻ khóa phân vùng, nhưng không phải khóa sắp xếp.

Các thuộc tính Khóa chính chỉ cho phép các giá trị vô hướng (đơn) và các kiểu dữ liệu chuỗi, số hoặc nhị phân. Các thuộc tính không phải khóa không có những hạn chế này.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 60. Sự khác biệt giữa danh sách và bảng băm là gì?

ArrayList là một tập hợp có thứ tự của các đối tượng, các đối tượng sẽ ở cùng thứ tự mà bạn đã thêm chúng vào ArrayList.

HashTable là một tập hợp các cặp Khóa Giá trị. Mỗi đối tượng trong HashTable được xác định bởi một Khóa và Giá trị.

Thông thường, ArrayList nhanh hơn HashTable trong việc chèn các phần tử trong một số trường hợp. Nhưng khi bạn cần tìm kiếm một phần tử, HashTable (sử dụng khóa để tìm kiếm) nhanh hơn ArrayList.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 61. Bạn đang cố gắng lưu trữ thông tin của mọi người trong một bảng băm. Bạn sẽ thiết kế khóa của mình như thế nào?

Tôi sẽ tạo một bảng băm trong đó tôi sẽ chèn một id số nguyên làm khóa và Map<People> làm giá trị.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 62. Từ khóa synchronized là gì và có những cách sử dụng khác nhau nào cho từ khóa synchronized?

Một đoạn logic được đánh dấu bằng synchronized trở thành một khối synchronized, cho phép chỉ một luồng thực thi tại bất kỳ thời điểm nào.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 63. Khối synchronized là gì? Sự khác biệt giữa khối synchronized và phương thức synchronized là gì?

Một đoạn logic được đánh dấu bằng synchronized trở thành một khối synchronized, cho phép chỉ một luồng thực thi tại bất kỳ thời điểm nào.

Phương thức synchronized cung cấp một khóa tương ứng với cấp lớp hoặc cấp đối tượng, trong khi khối synchronized cung cấp một khóa trên bất kỳ đối tượng nào tùy thuộc vào tham số.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 64. Giải thích về các bộ tích lũy đồng thời? Và tính đồng thời trong java?

Các lớp bộ tích lũy đồng thời cho phép bạn tăng/giảm giá trị của một bộ đếm một cách rất hiệu quả trong một cách an toàn với luồng. Đây thực sự là một trường hợp mà không phải là vấn đề về sở thích, hoặc sở thích - việc sử dụng các lớp mới này trong mã của bạn thực sự là một điều hiển nhiên.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 65. Các bộ tích lũy đồng thời trong java?

Các lớp bộ tích lũy đồng thời cho phép bạn tăng/giảm giá trị của một bộ đếm một cách rất hiệu quả trong một cách an toàn với luồng. Đây thực sự là một trường hợp mà không phải là vấn đề về sở thích, hoặc sở thích - việc sử dụng các lớp mới này trong mã của bạn thực sự là một điều hiển nhiên.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 66. Sự khác biệt giữa lưu trữ nóng và lưu trữ lạnh là gì?

**Lưu trữ nóng:** đại diện cho các tệp thường xuyên được sử dụng và quan trọng được lưu trữ ở rìa để truy cập nhanh tại chỗ.

**Lưu trữ ấm:** thường được minh họa là các tệp được lưu trữ trên một cổng lưu trữ đám mây hoặc máy chủ tệp/NAS để truy xuất nhanh, thường là tại trụ sở công ty hoặc văn phòng chi nhánh từ xa (ROBO).

**Lưu trữ lạnh:** không yêu cầu truy cập nhanh. Nó chủ yếu đại diện cho các tài liệu và dự án ít được truy cập và thường được lưu trữ trong các tầng lưu trữ đối tượng và đám mây có chi phí thấp.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 67. Lớp trừu tượng trong java là gì?

Một lớp được khai báo bằng từ khóa abstract được gọi là lớp trừu tượng trong Java. Nó có thể có các phương thức trừu tượng và không trừu tượng (phương thức có thân). Tính trừu tượng là một quá trình ẩn chi tiết thực hiện và chỉ hiển thị chức năng cho người dùng.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 68. Giao diện là gì?

Một giao diện trong Java là một bản thiết kế của một lớp. Nó có các hằng số tĩnh và các phương thức trừu tượng. Giao diện trong Java là một cơ chế để đạt được tính trừu tượng. Chỉ có các phương thức trừu tượng trong giao diện Java, không có thân phương thức. Nó được sử dụng để đạt được tính trừu tượng và kế thừa đa hình trong Java. Nói cách khác, bạn có thể nói rằng các giao diện có thể có các phương thức và biến trừu tượng. Nó không thể có thân phương thức. Giao diện Java cũng đại diện cho mối quan hệ IS-A.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 69. Sử dụng của equals trong JAVA là gì?

Phương thức equals() so sánh hai chuỗi và trả về true nếu các chuỗi bằng nhau, và false nếu không.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 70. EKS là gì?

Amazon Elastic Kubernetes Service (Amazon EKS) là một dịch vụ được quản lý mà bạn có thể sử dụng để chạy Kubernetes trên AWS mà không cần cài đặt, vận hành và duy trì cụm điều khiển Kubernetes hoặc các nút của riêng bạn.

Amazon Elastic Container Service for Kubernetes (EKS) là một dịch vụ quản lý container dựa trên đám mây mà tích hợp natively với Kubernetes để triển khai ứng dụng.

Dịch vụ EKS tự động quản lý và mở rộng các cụm tài nguyên hạ tầng trên AWS với Kubernetes, một công cụ mã nguồn mở cho việc điều phối container mà có thể khó khăn cho một doanh nghiệp tự quản lý.

Với Amazon EKS, một doanh nghiệp có thể sử dụng Kubernetes mà không cần cài đặt, vận hành hoặc quản lý phần mềm điều phối container.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 71. EKS hoạt động như thế nào?

Amazon Elastic Kubernetes Service (Amazon EKS) giúp dễ dàng triển khai, quản lý và mở rộng các ứng dụng container hóa bằng cách sử dụng Kubernetes trên Amazon Web Services.

Amazon EKS chạy hạ tầng quản lý Kubernetes cho bạn trên nhiều vùng khả dụng của Amazon Web Services để loại bỏ một điểm lỗi duy nhất. Amazon EKS được chứng nhận tương thích với Kubernetes, vì vậy bạn có thể sử dụng các công cụ và plugin hiện có từ các đối tác và cộng đồng Kubernetes. Các ứng dụng chạy trên bất kỳ môi trường Kubernetes tiêu chuẩn nào đều hoàn toàn tương thích và có thể dễ dàng di chuyển đến Amazon EKS.

Amazon EKS hiện có sẵn cho tất cả khách hàng của Amazon Web Services.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 72. Bạn chạy lệnh gì trên EKS?

https://docs.aws.amazon.com/cli/latest/reference/eks/index.html

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 73. Phiên bản hóa là gì?

Phiên bản hóa là một phương tiện để giữ nhiều hình thức của một đối tượng trong cùng một bucket S3. Phiên bản hóa có thể được sử dụng để truy xuất, bảo tồn và khôi phục mọi phiên bản của một đối tượng trong bucket S3.

Các bucket được bật phiên bản hóa cho phép bạn khôi phục các đối tượng từ việc xóa hoặc ghi đè. Nó phục vụ hai mục đích:

- Nếu bạn xóa một đối tượng, thay vì xóa đối tượng vĩnh viễn, nó tạo ra một dấu hiệu xóa trở thành phiên bản hiện tại của một đối tượng.
- Nếu bạn ghi đè một đối tượng, nó tạo ra một phiên bản mới của đối tượng và cũng khôi phục phiên bản trước đó của đối tượng.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 74. Bạn hiểu gì về vòng đời của một luồng?

Một luồng có thể ở một trong năm trạng thái. Theo Sun, chỉ có 4 trạng thái trong vòng đời luồng trong Java: mới, có thể chạy, không thể chạy và đã kết thúc. Không có trạng thái đang chạy.

Nhưng để hiểu rõ hơn về các luồng, chúng tôi giải thích nó trong 5 trạng thái.

Vòng đời của luồng trong java được điều khiển bởi JVM. Các trạng thái luồng java như sau:

- Mới
- Có thể chạy
- Đang chạy
- Không thể chạy (Bị chặn)
- Đã kết thúc

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 75. "Phiên bản hóa đối tượng" có nghĩa là gì?

Phiên bản hóa là việc tạo ra và quản lý nhiều phiên bản phát hành của một sản phẩm, tất cả đều có chức năng chung nhưng được cải tiến, nâng cấp hoặc tùy chỉnh. Thuật ngữ này đặc biệt áp dụng cho các hệ điều hành (OS), phần mềm và dịch vụ Web.

Bạn có thể sử dụng phiên bản hóa để giữ nhiều phiên bản của một đối tượng, điều này bảo vệ chống lại việc xóa đối tượng một cách tình cờ và cho phép bạn truy xuất và khôi phục các phiên bản trước đó của một đối tượng.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 76. Sự khác biệt giữa rest và soap là gì? Đâu là an toàn hơn: rest hay soap?

| SOAP                                                                                                  | REST                                                                                             |
| ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| SOAP là một giao thức.                                                                                   | REST là một phong cách kiến trúc.                                                                  |
| SOAP là viết tắt của Simple Object Access Protocol.                                                        | REST là viết tắt của REpresentational State Transfer.                                                 |
| SOAP không thể sử dụng REST vì nó là một giao thức.                                                           | REST có thể sử dụng dịch vụ web SOAP vì nó là một khái niệm và có thể sử dụng bất kỳ giao thức nào như HTTP, SOAP. |
| SOAP sử dụng Giao diện Dịch vụ để công khai logic kinh doanh.                                           | REST sử dụng URI để công khai logic kinh doanh.                                                          |
| JAX-WS là API Java cho dịch vụ web SOAP.                                                         | JAX-RS là API Java cho dịch vụ web RESTful.                                                 |
| SOAP định nghĩa các tiêu chuẩn phải được tuân thủ nghiêm ngặt.                                                       | Rest không định nghĩa quá nhiều tiêu chuẩn như SOAP.                                              |
| SOAP an toàn hơn REST vì nó sử dụng WS-Security cho truyền tải cùng với Secure Socket Layer. | REST ít an toàn hơn SOAP.                                                                   |

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 77. Sự khác biệt giữa compute và Kubernetes engine là gì?

**Kubernetes** là một dịch vụ điều phối container mã nguồn mở cấp độ sản xuất để tự động hóa việc triển khai, mở rộng và quản lý các khối lượng công việc và dịch vụ container hóa.

**Google App Engine** là một dịch vụ được quản lý bởi Google Cloud Platform để xây dựng và chạy các ứng dụng dưới dạng container.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 78. Sự khác biệt giữa @component & @bean là gì?

| STT | Khóa                           | @bean                                                                                           | @component                                                                                         |
| --- | ----------------------------- | ----------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| 1   | Tự động phát hiện                | Nó được sử dụng để khai báo một bean duy nhất một cách rõ ràng, thay vì để Spring tự động làm điều đó. | Nếu bất kỳ lớp nào được chú thích bằng @Component, nó sẽ được tự động phát hiện bằng cách sử dụng quét classpath. |
| 2   | Container Spring              | Bean có thể được tạo ra ngay cả khi lớp nằm ngoài container spring                                  | Chúng ta không thể tạo bean nếu lớp nằm ngoài container spring                                          |
| 3   | Chú thích Cấp lớp/Phương thức | Đây là một chú thích cấp phương thức                                                                 | Đây là một chú thích cấp lớp                                                                     |
| 4   | @Configuration                | Nó chỉ hoạt động khi lớp cũng được chú thích bằng @Configuration                                  | Nó hoạt động mà không cần chú thích @Configuration                                                         |
| 5   | Trường hợp sử dụng                      | Chúng ta nên sử dụng @bean, nếu bạn muốn triển khai cụ thể dựa trên điều kiện động.            | Chúng ta không thể viết triển khai cụ thể dựa trên điều kiện động                                  |

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 79. Cho tôi biết lợi ích của việc sử dụng biểu thức lambda Java8 là gì?

Biểu thức lambda về cơ bản thể hiện các thể hiện của các giao diện chức năng (Một giao diện với một phương thức trừu tượng duy nhất được gọi là giao diện chức năng. Một ví dụ là java.lang.Runnable). Biểu thức lambda triển khai chức năng trừu tượng duy nhất và do đó triển khai các giao diện chức năng.

Biểu thức lambda được thêm vào Java 8 và cung cấp các chức năng dưới đây:

- Cho phép xem xét chức năng như một đối số phương thức, hoặc mã như dữ liệu.
- Một hàm có thể được tạo mà không thuộc về bất kỳ lớp nào.
- Một biểu thức lambda có thể được truyền xung quanh như thể nó là một đối tượng và được thực thi theo yêu cầu.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 80. Predicate trong java là gì?

Predicate trong Java được thực hiện bằng các giao diện. Predicate<T> là một giao diện chức năng tổng quát đại diện cho một hàm một đối số trả về giá trị boolean. Nó nằm trong gói java.util.function. Nó chứa một phương thức test(T t) đánh giá predicate trên đối số cho trước.

Một Giao diện Chức năng là một giao diện cho phép chỉ một phương thức Trừu tượng trong phạm vi Giao diện. Có một số giao diện chức năng được định nghĩa sẵn trong Java như Predicate, consumer, supplier, v.v. Kiểu trả về của một hàm Lambda (được giới thiệu trong JDK 1.8) cũng là một giao diện chức năng.

Giao diện Chức năng PREDICATE được định nghĩa trong gói java.util.Function. Nó cải thiện khả năng quản lý mã, giúp trong việc kiểm tra đơn vị chúng riêng biệt và chứa một số phương thức.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 81. Cách tạo một lớp singleton?

Mẫu Singleton nói rằng chỉ cần "định nghĩa một lớp chỉ có một thể hiện và cung cấp một điểm truy cập toàn cầu đến nó".

Có hai hình thức của mẫu thiết kế singleton -

- Khởi tạo sớm: việc tạo ra các thể hiện tại thời điểm tải.
- Khởi tạo lười: việc tạo ra các thể hiện khi cần thiết.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 82. Bạn có biết về giao diện marker không?

Một giao diện không chứa phương thức, trường và hằng số được gọi là giao diện marker. Nói cách khác, một giao diện trống được gọi là giao diện marker hoặc giao diện tag. Nó cung cấp thông tin kiểu thời gian chạy về một đối tượng. Đó là lý do mà JVM và trình biên dịch có thêm thông tin về một đối tượng. Tóm lại, nó chỉ ra một tín hiệu hoặc lệnh cho JVM.

java.lang.Cloneable và java.io.Serializable là các ví dụ về giao diện marker.

Khai báo của giao diện marker giống như giao diện trong Java nhưng giao diện phải trống. Ví dụ:

```java
public interface Serializable
{

}
```

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 83. Khi nào bạn sử dụng serialization?

Serialization trong Java là một cơ chế để ghi trạng thái của một đối tượng vào một luồng byte. Nó chủ yếu được sử dụng trong các công nghệ Hibernate, RMI, JPA, EJB và JMS.

Hoạt động ngược lại của serialization được gọi là deserialization, nơi một luồng byte được chuyển đổi thành một đối tượng. Quá trình serialization và deserialization là độc lập với nền tảng, có nghĩa là bạn có thể serialize một đối tượng trên một nền tảng và deserialization nó trên một nền tảng khác.

Để serialize đối tượng, chúng ta gọi phương thức writeObject() của ObjectOutputStream, và để deserialization chúng ta gọi phương thức readObject() của lớp ObjectInputStream.

Chúng ta phải triển khai giao diện Serializable để serialize đối tượng.

Nó chủ yếu được sử dụng để truyền trạng thái của một đối tượng qua mạng (được gọi là marshaling).

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 84. Materialized view trong java là gì?

Materialized views là các views tương tự như các views bình thường ngoại trừ một thuộc tính rằng chúng được làm mới nhanh hơn. Những views này được cập nhật tự động khi có bất kỳ cập nhật nào xảy ra trong bảng chính.

- Nó là một bản sao logic và ảo của dữ liệu.
- Nó là kết quả của một 'truy vấn chọn', với điều kiện rằng truy vấn được lưu trữ trong bảng hoặc đĩa.
- Biểu thức truy vấn và bộ kết quả được lưu trữ trên đĩa.
- Biểu thức truy vấn không được thực thi mỗi khi người dùng cố gắng lấy dữ liệu.
- Điều này có nghĩa là, người dùng không nhận được các giá trị được cập nhật gần đây nhất của một bảng trong cơ sở dữ liệu.
- Nó có chi phí lưu trữ và cập nhật liên quan đến nó.
- Chúng được thiết kế với một kiến trúc tổng quát, do đó không có tiêu chuẩn SQL để định nghĩa nó.
- Chức năng của nó được cung cấp bởi một số cơ sở dữ liệu như một phần mở rộng.
- Nó được sử dụng khi dữ liệu phải được truy cập thường xuyên nhưng dữ liệu trong bảng không được cập nhật thường xuyên.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 85. NFR là gì?

Các yêu cầu không chức năng (NFR) định nghĩa các thuộc tính hệ thống như bảo mật, độ tin cậy, hiệu suất, khả năng bảo trì, khả năng mở rộng và khả năng sử dụng. Chúng phục vụ như các ràng buộc hoặc hạn chế đối với thiết kế của hệ thống trên các backlog khác nhau.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 86. Khả năng phục hồi trong java là gì?

Khả năng phục hồi của một ứng dụng là khả năng phục hồi từ các lỗi. Các ứng dụng dựa trên microservices thường có nhiều phụ thuộc - bao gồm cơ sở dữ liệu, các thành phần phía sau và API - có thể gây ra các lỗi gọi dịch vụ, được phân loại là;

- Lỗi tạm thời
- Lỗi vĩnh viễn

Có ba mẫu khả năng phục hồi microservices đã được chứng minh giúp tăng cường khả năng chịu lỗi và cho phép các ứng dụng xử lý các lỗi một cách duyên dáng.

**Retry:**

Microservices thường có nhiều phụ thuộc, bao gồm cơ sở dữ liệu, các thành phần, dịch vụ phía sau và API. Bất kỳ phụ thuộc nào trong số này có thể thất bại tạm thời, và do đó tạo ra nhiều lỗi gọi dịch vụ. Mẫu retry cung cấp một giải pháp cho những lỗi tạm thời này.

**Circuit Breaker:**

Trong khi mẫu retry hoạt động cho các lỗi tạm thời, các nhóm vẫn cần một mẫu khả năng phục hồi microservices đáng tin cậy xử lý các lỗi lớn hơn, lâu dài và vĩnh viễn. Nếu một cơ chế retry vô tình gọi một dịch vụ bị hỏng nghiêm trọng nhiều lần cho đến khi nó nhận được kết quả mong muốn, điều này có thể dẫn đến các lỗi dịch vụ lan truyền trở nên ngày càng khó xác định và sửa chữa.

**Correlation ID:**

Trong một ứng dụng dựa trên microservices điển hình, nhiều dịch vụ trải dài qua các hệ thống khác nhau, có thể cách xa nhau về mặt địa lý. Điều này có nghĩa là mỗi dịch vụ phải ghi lại dữ liệu hữu ích và có ý nghĩa chỉ ra những gì nó đã làm và chi tiết bất kỳ lỗi nào. Điều này yêu cầu một mẫu khả năng phục hồi microservices thứ ba hướng đến việc theo dõi dịch vụ.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 87. Giải thích về mẫu circuit breaker?

Ý tưởng cơ bản đằng sau bộ ngắt mạch rất đơn giản. Bạn bọc một cuộc gọi hàm được bảo vệ trong một đối tượng bộ ngắt mạch, theo dõi nó để phát hiện lỗi. Khi chúng ta áp dụng mẫu này, chúng ta ngăn chặn các vấn đề ứng dụng có thể xảy ra. Mẫu này theo cùng một khái niệm như một thành phần điện an toàn được gọi là bộ ngắt mạch.

Khi số lượng lỗi đạt đến một ngưỡng nhất định, bộ ngắt mạch bị tripped, và tất cả các cuộc gọi tiếp theo đến bộ ngắt mạch sẽ trả về một lỗi hoặc một dịch vụ thay thế nào đó hoặc thông điệp mặc định, mà không thực hiện cuộc gọi được bảo vệ. Điều này sẽ đảm bảo rằng hệ thống phản hồi và các luồng không chờ đợi một cuộc gọi không phản hồi, bảo vệ hệ thống để tránh các lỗi thảm khốc.

- Trong trường hợp dịch vụ B bị hỏng, dịch vụ A nên cố gắng phục hồi từ điều này và cố gắng thực hiện một trong các hành động sau:
- Dự phòng tùy chỉnh: Cố gắng lấy cùng một dữ liệu từ một nguồn khác. Nếu không thể, hãy sử dụng giá trị bộ nhớ cache của chính nó hoặc phản hồi lỗi tùy chỉnh của bạn.
- Fail fast: Nếu dịch vụ A biết rằng dịch vụ B đang bị hỏng, thì không có lý do gì để chờ đợi thời gian chờ và tiêu tốn tài nguyên của chính nó.
- Heal automatic: Thường xuyên kiểm tra xem dịch vụ B có hoạt động trở lại không.
- Các API khác nên hoạt động: Tất cả các API khác nên tiếp tục hoạt động.

**Nó hoạt động như thế nào?**
![image](https://user-images.githubusercontent.com/649439/168875117-6d714484-edec-4f4c-95c4-3fe7d165b669.png)

**Đóng:** Khi mọi thứ bình thường, bộ ngắt mạch vẫn ở trạng thái ĐÓNG và tất cả các cuộc gọi đến dịch vụ B diễn ra bình thường. Khi số lượng lỗi vượt quá một giới hạn đã xác định, trạng thái chuyển sang MỞ.

**Mở:** Trong trạng thái này, bộ ngắt mạch sẽ không thực hiện cuộc gọi dịch vụ B và trả về một lỗi đã được xử lý.

**Nửa Mở:** Sau một khoảng thời gian chờ, bộ ngắt mạch chuyển sang trạng thái nửa mở để kiểm tra xem vấn đề cơ bản vẫn tồn tại hay không. Nếu một cuộc gọi duy nhất thất bại trong trạng thái NỬA MỞ này, bộ ngắt mạch lại bị tripped. Nếu nó thành công, bộ ngắt mạch được đặt lại về trạng thái bình thường, ĐÓNG.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 88. Trong java, bạn đã sử dụng bất kỳ mẫu thiết kế nào chưa?

**Mẫu thiết kế trong Java -\***
Một mẫu thiết kế là một giải pháp đã được chứng minh cho việc giải quyết một vấn đề/nhiệm vụ cụ thể.

**Lợi ích của mẫu thiết kế:**

- Chúng có thể được sử dụng lại trong nhiều dự án.
- Chúng cung cấp các giải pháp giúp định nghĩa kiến trúc hệ thống.
- Chúng nắm bắt kinh nghiệm kỹ thuật phần mềm.
- Chúng cung cấp sự minh bạch cho thiết kế của một ứng dụng.
- Chúng là những giải pháp đã được chứng minh và kiểm nghiệm vì chúng được xây dựng dựa trên kiến thức và kinh nghiệm của các nhà phát triển phần mềm chuyên gia.
- Các mẫu thiết kế không đảm bảo một giải pháp tuyệt đối cho một vấn đề. Chúng cung cấp sự rõ ràng cho kiến trúc hệ thống và khả năng xây dựng một hệ thống tốt hơn.

**Phân loại các mẫu thiết kế:**
Về cơ bản, các mẫu thiết kế được phân loại thành hai phần:

1. Mẫu thiết kế Core Java (hoặc JSE).
2. Mẫu thiết kế JEE.

**Mẫu thiết kế Core Java**
Trong core java, chủ yếu có ba loại mẫu thiết kế, được chia thành các phần phụ:

**1.Mẫu thiết kế Tạo ra**

- Mẫu Factory
- Mẫu Abstract Factory
- Mẫu Singleton
- Mẫu Prototype
- Mẫu Builder.

**2. Mẫu thiết kế Cấu trúc**

- Mẫu Adapter
- Mẫu Bridge
- Mẫu Composite
- Mẫu Decorator
- Mẫu Facade
- Mẫu Flyweight
- Mẫu Proxy

**3. Mẫu thiết kế Hành vi**

- Mẫu Chain Of Responsibility
- Mẫu Command
- Mẫu Interpreter
- Mẫu Iterator
- Mẫu Mediator
- Mẫu Memento
- Mẫu Observer
- Mẫu State
- Mẫu Strategy
- Mẫu Template
- Mẫu Visitor

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 89. Có những cách nào để tạo một luồng?

Có hai cách để tạo một luồng:

1. Bằng cách mở rộng lớp Thread
2. Bằng cách triển khai giao diện Runnable.

**Lớp Thread:**
Lớp Thread cung cấp các bộ khởi tạo và phương thức để tạo và thực hiện các thao tác trên một luồng. Lớp Thread mở rộng lớp Object và triển khai giao diện Runnable.

**Các bộ khởi tạo thường được sử dụng của lớp Thread:**

- Thread()
- Thread(String name)
- Thread(Runnable r)
- Thread(Runnable r, String name)

**Khởi động một luồng:**
Phương thức start() của lớp Thread được sử dụng để khởi động một luồng mới được tạo. Nó thực hiện các tác vụ sau:

- Một luồng mới bắt đầu (với một ngăn xếp gọi mới)
- Luồng chuyển từ trạng thái Mới sang trạng thái Có thể chạy.
- Khi luồng có cơ hội thực thi, phương thức mục tiêu run() của nó sẽ chạy.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 90. Spring Annotation là gì? Vui lòng cho ví dụ?

Các chú thích Spring Boot là một hình thức siêu dữ liệu cung cấp dữ liệu về một chương trình.
Nói cách khác, các chú thích được sử dụng để cung cấp thông tin bổ sung về một chương trình. Nó không phải là một phần của ứng dụng mà chúng tôi phát triển. Nó không có tác động trực tiếp đến hoạt động của mã mà chúng chú thích. Nó không thay đổi hành động của chương trình đã biên dịch.

Chúng ta có thể tận dụng các khả năng của động cơ DI của Spring bằng cách sử dụng các chú thích trong các gói org.springframework.beans.factory.annotation và org.springframework.context.annotation.

**Chú thích liên quan đến DI -**

**@Autowired:** Chúng ta có thể sử dụng @Autowired để đánh dấu một phụ thuộc mà Spring sẽ giải quyết và tiêm. Chúng ta có thể sử dụng chú thích này với việc tiêm qua bộ tạo, bộ thiết lập hoặc trường. @Autowired có một tham số boolean gọi là required với giá trị mặc định là true. Nó điều chỉnh hành vi của Spring khi không tìm thấy một bean phù hợp để kết nối. Khi true, một ngoại lệ sẽ được ném ra, ngược lại, không có gì được kết nối.

**@Bean:** @Bean đánh dấu một phương thức nhà máy mà khởi tạo một bean Spring.

**@Qualifier:** Chúng ta sử dụng @Qualifier cùng với @Autowired để cung cấp id bean hoặc tên bean mà chúng ta muốn sử dụng trong các tình huống mơ hồ.

**@Required:** @Required trên các phương thức thiết lập để đánh dấu các phụ thuộc mà chúng ta muốn điền thông qua XML.

**@Value:** Chúng ta có thể sử dụng @Value để tiêm các giá trị thuộc tính vào các bean. Nó tương thích với việc tiêm qua bộ tạo, bộ thiết lập và trường.

**@DependsOn:** Chúng ta có thể sử dụng chú thích này để yêu cầu Spring khởi tạo các bean khác trước bean được chú thích. Thông thường, hành vi này là tự động, dựa trên các phụ thuộc rõ ràng giữa các bean.

**@Lazy:** Chúng ta sử dụng @Lazy khi chúng ta muốn khởi tạo bean của mình một cách lười biếng. Theo mặc định, Spring tạo tất cả các bean singleton một cách háo hức khi khởi động/khởi tạo ngữ cảnh ứng dụng.

**@Lookup:** Một phương thức được chú thích bằng @Lookup cho biết Spring sẽ trả về một thể hiện của loại trả về của phương thức khi chúng ta gọi nó.

**@Primary:** Đôi khi chúng ta cần định nghĩa nhiều bean cùng loại. Trong những trường hợp này, việc kết nối sẽ không thành công vì Spring không có manh mối về bean mà chúng ta cần.

**@Scope:** Chúng ta sử dụng @Scope để định nghĩa phạm vi của một lớp @Component hoặc một định nghĩa @Bean. Nó có thể là singleton, prototype, request, session, globalSession hoặc một phạm vi tùy chỉnh nào đó.

**Chú thích cấu hình ngữ cảnh -**

**@Profile:** Nếu chúng ta muốn Spring sử dụng một lớp @Component hoặc một phương thức @Bean chỉ khi một hồ sơ cụ thể đang hoạt động, chúng ta có thể đánh dấu nó bằng @Profile.

**@Import:** Chúng ta có thể sử dụng các lớp @Configuration cụ thể mà không cần quét thành phần với chú thích này.

**@ImportResource:** Chúng ta có thể nhập các cấu hình XML với chú thích này. Chúng ta có thể chỉ định các vị trí tệp XML với tham số locations, hoặc với tham số bí danh của nó, tham số value.

**@PropertySource:** Với chú thích này, chúng ta có thể định nghĩa các tệp thuộc tính cho các cài đặt ứng dụng.

**@PropertySources:** Chúng ta có thể sử dụng chú thích này để chỉ định nhiều cấu hình @PropertySource.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 91. Splunk là gì? Dữ liệu sẽ đến Splunk như thế nào?

Splunk là một công nghệ tiên tiến, có thể mở rộng và hiệu quả mà lập chỉ mục và tìm kiếm các tệp nhật ký được lưu trữ trong một hệ thống. Nó phân tích dữ liệu được tạo ra bởi máy để cung cấp thông tin hoạt động. Lợi ích chính của việc sử dụng Splunk là nó không cần bất kỳ cơ sở dữ liệu nào để lưu trữ dữ liệu của mình, vì nó sử dụng rộng rãi các chỉ mục của mình để lưu trữ dữ liệu.

Splunk là một phần mềm xử lý và mang lại thông tin từ dữ liệu máy và các hình thức dữ liệu lớn khác. Dữ liệu máy này được tạo ra bởi một CPU chạy máy chủ web, các thiết bị IoT, nhật ký từ các ứng dụng di động, v.v. Không cần thiết phải cung cấp dữ liệu này cho người dùng cuối và không có ý nghĩa kinh doanh nào. Tuy nhiên, chúng rất quan trọng để hiểu, theo dõi và tối ưu hóa hiệu suất của các máy.

#### Tính năng của Splunk -

**Nhập dữ liệu**
Splunk có thể nhập nhiều định dạng dữ liệu như JSON, XML và dữ liệu máy không có cấu trúc như nhật ký web và ứng dụng. Dữ liệu không có cấu trúc có thể được mô hình hóa thành một cấu trúc dữ liệu theo yêu cầu của người dùng.

**Lập chỉ mục dữ liệu**
Dữ liệu đã nhập được lập chỉ mục bởi Splunk để tìm kiếm và truy vấn nhanh hơn trên các điều kiện khác nhau.

**Tìm kiếm dữ liệu**
Tìm kiếm trong Splunk liên quan đến việc sử dụng dữ liệu đã được lập chỉ mục nhằm mục đích tạo ra các chỉ số, dự đoán các xu hướng trong tương lai và xác định các mẫu trong dữ liệu.

**Sử dụng cảnh báo**
Cảnh báo Splunk có thể được sử dụng để kích hoạt email hoặc RSS khi một số tiêu chí cụ thể được tìm thấy trong dữ liệu đang được phân tích.

**Bảng điều khiển**
Bảng điều khiển Splunk có thể hiển thị các kết quả tìm kiếm dưới dạng biểu đồ, báo cáo, pivot, v.v.

**Mô hình dữ liệu**
Dữ liệu đã được lập chỉ mục có thể được mô hình hóa thành một hoặc nhiều tập dữ liệu dựa trên kiến thức miền chuyên biệt.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 92. Mẫu Resiliency trong Java là gì?

**Thiết kế Microservice Resilient - Mẫu Bulkhead:**
Khả năng phục hồi của hệ thống từ lỗi và vẫn giữ được chức năng khiến hệ thống trở nên mạnh mẽ hơn. Nó cũng tránh bất kỳ lỗi lan truyền nào.

**Nhu cầu về khả năng phục hồi:**
MicroServices có tính chất phân tán. Nó có nhiều thành phần và bộ phận di chuyển hơn. Trong một kiến trúc phân tán, việc xử lý bất kỳ lỗi bất ngờ nào là một trong những thách thức lớn nhất cần giải quyết. Nó có thể là lỗi phần cứng, lỗi mạng, v.v. Khả năng phục hồi của hệ thống từ lỗi và vẫn giữ được chức năng khiến hệ thống trở nên mạnh mẽ hơn. Nó cũng tránh bất kỳ lỗi lan truyền nào.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 93. Mẫu circuit breaker là gì?

Khi một dịch vụ đồng bộ gọi một dịch vụ khác, luôn có khả năng rằng dịch vụ khác không khả dụng hoặc đang thể hiện độ trễ cao đến mức nó về cơ bản không thể sử dụng được. Các tài nguyên quý giá như luồng có thể bị tiêu tốn bởi người gọi trong khi chờ đợi dịch vụ khác phản hồi.

**Vấn đề**
Làm thế nào để ngăn chặn một lỗi mạng hoặc dịch vụ từ việc lan truyền đến các dịch vụ khác?

**Giải pháp**
Một khách hàng dịch vụ nên gọi một dịch vụ từ xa thông qua một proxy hoạt động theo cách tương tự như một bộ ngắt mạch điện. Khi số lượng lỗi liên tiếp vượt qua một ngưỡng, bộ ngắt mạch bị tripped, và trong thời gian của một khoảng thời gian chờ, tất cả các nỗ lực gọi dịch vụ từ xa sẽ thất bại ngay lập tức. Sau khi thời gian chờ hết hạn, bộ ngắt mạch cho phép một số yêu cầu thử nghiệm giới hạn đi qua. Nếu những yêu cầu đó thành công, bộ ngắt mạch tiếp tục hoạt động bình thường. Ngược lại, nếu có một lỗi, thời gian chờ bắt đầu lại.

**Bộ ngắt mạch có ba giai đoạn khác nhau:**

1. Đóng
2. Mở
3. Nửa Mở

**Đóng –** Khi mọi thứ bình thường, bộ ngắt mạch vẫn ở trạng thái đóng và tất cả các cuộc gọi đi qua dịch vụ. Khi số lượng lỗi vượt quá một ngưỡng đã xác định, bộ ngắt mạch bị tripped, và nó chuyển sang trạng thái MỞ.

**Mở –** Bộ ngắt mạch trả về một lỗi cho các cuộc gọi mà không thực hiện hàm.

**Nửa Mở –** Sau một khoảng thời gian chờ, bộ ngắt mạch chuyển sang trạng thái nửa mở để kiểm tra xem vấn đề cơ bản vẫn tồn tại hay không. Nếu một cuộc gọi duy nhất thất bại trong trạng thái nửa mở này, bộ ngắt mạch lại bị tripped. Nếu nó thành công, bộ ngắt mạch được đặt lại về trạng thái bình thường, ĐÓNG.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 94. Hibernate criteria builder là gì?

Hibernate cung cấp các phương pháp thay thế để thao tác các đối tượng và từ đó dữ liệu có sẵn trong các bảng RDBMS. Một trong những phương pháp là Criteria API, cho phép bạn xây dựng một đối tượng truy vấn tiêu chí một cách lập trình, nơi bạn có thể áp dụng các quy tắc lọc và các điều kiện logic.

Giao diện Session của Hibernate cung cấp phương thức createCriteria(), có thể được sử dụng để tạo một đối tượng Criteria trả về các thể hiện của lớp đối tượng lưu trữ khi ứng dụng của bạn thực hiện một truy vấn tiêu chí.

**Hạn chế với Criteria**
Bạn có thể sử dụng phương thức add() có sẵn cho đối tượng Criteria để thêm các hạn chế cho một truy vấn tiêu chí.

**Phân trang bằng Criteria**
Có hai phương thức của giao diện Criteria cho phân trang.

**1. public Criteria setFirstResult(int firstResult)**
Phương thức này nhận một số nguyên đại diện cho hàng đầu tiên trong tập kết quả của bạn, bắt đầu từ hàng 0.

**2. public Criteria setMaxResults(int maxResults)**
Phương thức này cho Hibernate biết để lấy một số lượng cố định maxResults của đối tượng.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 95. Sự khác biệt giữa put và patch là gì?

Khi một khách hàng cần thay thế một Tài nguyên hiện có hoàn toàn, họ có thể sử dụng PUT. Khi họ thực hiện một cập nhật phần, họ có thể sử dụng HTTP PATCH.

Ví dụ, khi cập nhật một trường duy nhất của Tài nguyên, việc gửi toàn bộ đại diện Tài nguyên có thể là cồng kềnh và sử dụng băng thông không cần thiết. Trong những trường hợp như vậy, ngữ nghĩa của PATCH có nhiều ý nghĩa hơn.

Một khía cạnh quan trọng khác cần xem xét ở đây là tính đồng nhất; PUT là đồng nhất; PATCH có thể là, nhưng không yêu cầu. Và, vì vậy - tùy thuộc vào ngữ nghĩa của thao tác mà chúng ta đang triển khai, chúng ta cũng có thể chọn một trong hai dựa trên đặc điểm này.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 96. Java Streams là gì?

Java cung cấp một gói bổ sung mới trong Java 8 gọi là java.util.stream. Gói này bao gồm các lớp, giao diện và enum cho phép các hoạt động kiểu chức năng trên các phần tử. Bạn có thể sử dụng luồng bằng cách nhập gói java.util.stream.

Bằng cách sử dụng luồng, bạn có thể xử lý dữ liệu theo cách khai báo tương tự như các câu lệnh SQL. Bạn có thể sử dụng luồng để lọc, thu thập, in và chuyển đổi từ một cấu trúc dữ liệu này sang một cấu trúc dữ liệu khác, v.v.

**Tạo luồng**
Với Java 8, giao diện Collection có hai phương thức để tạo một Luồng.

1. stream() − Trả về một luồng tuần tự xem xét tập hợp như nguồn của nó.
2. parallelStream() − Trả về một Luồng song song xem xét tập hợp như nguồn của nó.

**Luồng cung cấp các tính năng sau:**

- Luồng không lưu trữ các phần tử. Nó chỉ chuyển tải các phần tử từ một nguồn như một cấu trúc dữ liệu, một mảng hoặc một kênh I/O, thông qua một chuỗi các phép toán tính toán.
- Các luồng có tính chất chức năng. Các thao tác thực hiện trên một luồng không thay đổi nguồn của nó. Ví dụ, lọc một Luồng thu được từ một tập hợp tạo ra một Luồng mới mà không có các phần tử đã lọc, thay vì loại bỏ các phần tử từ tập hợp nguồn.
- Luồng là lười biếng và chỉ đánh giá mã khi cần thiết.
- Các phần tử của một luồng chỉ được truy cập một lần trong suốt vòng đời của luồng. Giống như một Iterator, một luồng mới phải được tạo ra để truy cập lại cùng một phần tử từ nguồn.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 97. Tại sao các biến trong giao diện là public, static, final?

**static:** Chúng ta không tạo thể hiện của Giao diện, vì vậy để truy cập các biến này, chúng ta chỉ có tên giao diện, vì vậy: các biến trong java là static.

**final:** Để biến chúng thành các hằng số. Nếu 2 lớp triển khai cùng một giao diện và bạn cho phép cả hai thay đổi giá trị, sẽ xảy ra xung đột trong giá trị hiện tại của biến, đó là lý do tại sao chỉ cho phép khởi tạo một lần.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 98. Tại sao các biến trong giao diện không cần khai báo trong các lớp thực thi?

Các biến trong java mặc định là public static final, vì vậy nếu bất kỳ lớp nào thực hiện các biến này, chúng ta có thể sử dụng các biến này bằng cách sử dụng tên giao diện. Việc ghi đè các biến là không có trong java.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 99. Điều gì sẽ xảy ra nếu bạn đặt câu lệnh return hoặc System.exit() trong khối try hoặc catch? Khối finally có thực thi không?

Nhiều lập trình viên nghĩ rằng không quan trọng điều gì, nhưng khối finally sẽ luôn thực thi. Câu hỏi này thách thức khái niệm đó bằng cách đặt một câu lệnh return trong khối try hoặc catch hoặc gọi System.exit() từ khối try hoặc catch. Câu trả lời cho câu hỏi khó này trong Java là khối finally sẽ thực thi ngay cả khi bạn đặt một câu lệnh return trong khối try hoặc khối catch nhưng khối finally sẽ không chạy nếu bạn gọi System.exit() từ khối try hoặc khối catch.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 100. Bạn có thể ghi đè một phương thức private hoặc static trong Java không?

Bạn không thể ghi đè một phương thức private hoặc static trong Java, nếu bạn tạo một phương thức tương tự với cùng kiểu trả về và cùng tham số trong lớp con thì nó sẽ ẩn phương thức của lớp cha, điều này được gọi là ẩn phương thức.

Tương tự, bạn không thể ghi đè một phương thức private trong lớp con vì nó không thể truy cập ở đó, những gì bạn làm là tạo một phương thức private khác với cùng tên trong lớp con.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 101. Chương trình Java sau đây in ra cái gì?

```java
public class Test {
  public static void main ( String [] args) {
    System. out . println( Math. min( Double. MIN_VALUE , 0.0d ));
  }
}
```

Câu hỏi này khó khăn vì không giống như Integer, nơi MIN_VALUE là số âm, cả MAX_VALUE và MIN_VALUE của lớp Double đều là các số dương. Double.MIN_VALUE là 2^(-1074), một hằng số double có độ lớn nhỏ nhất trong tất cả các giá trị double. Vì vậy, không giống như câu trả lời hiển nhiên, chương trình này sẽ in ra 0.0 vì Double.MIN_VALUE lớn hơn 0. Tôi đã hỏi câu hỏi này với các nhà phát triển Java có kinh nghiệm từ 3 đến 5 năm và thật ngạc nhiên, gần 70% ứng viên đã trả lời sai.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**


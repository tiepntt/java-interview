# Câu Hỏi Phỏng Vấn Java - Đáp Án

Nếu bạn đang chuẩn bị cho cuộc phỏng vấn Java, đây là hơn 100 câu hỏi phỏng vấn Java quan trọng cùng với đáp án chỉ dành cho bạn, bao gồm một số câu hỏi khó với đáp án.

### Mục Lục
| STT          | Câu Hỏi      | 
| ------------- |-------------| 
| 1             |[Các tính năng mới của Java 8 là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#1-new-java8-features) | 
| 2             |[Sự khác biệt giữa phương thức GET và POST?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#2-difference-between-get--post-methods) |
| 3             |[Sự khác biệt giữa phương thức forward() và phương thức SendRedirect()?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#3-difference-between-forward-method--sendredirect-method) |
| 4             |[Sự khác biệt giữa HashMap và HashTable?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#4-difference-between-hashmap-and-hashtable) |
| 5             |[Sự khác biệt giữa HashSet và TreeSet?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#5-difference-between-hashset-and-treeset) |
| 6             |[Collections trong Java có nghĩa là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#6-what-is-meant-by-collections-in-java) | 
| 7             |[Ordered và Sorted trong collections có nghĩa là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#7-what-is-meant-by-ordered-and-sorted-in-collections) |
| 8             |[Giải thích về Set và các loại của nó trong một collection?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#8-explain-about-set-and-their-types-in-a-collection) |
| 9             |[Từ khóa final trong Java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#9-what-is-the-final-keyword-in-java) |
| 10             |[Thread là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#10-what-is-a-thread) |
| 11             |[Giải thích vòng đời của thread trong Java](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#11explain-thread-life-cycle-in-java) |
| 12             |[Các phương thức nào được sử dụng trong quá trình Serialization và Deserialization?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#12-which-methods-are-used-during-the-serialization-and-deserialization-process) |
| 13             |[Khi nào sử dụng interface Runnable so với lớp Thread trong Java?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#13-when-to-use-runnable-interface-vs-thread-class-in-java) |
| 14             |[Vòng đời của một servlet là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#14-what-is-the-life-cycle-of-a-servlet) |
| 15             |[Sự khác biệt giữa ServletContext và ServletConfig?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#15-differences-between-servletcontext-vs-servletconfig) |
| 16             |[Sự khác biệt giữa SPRING CORE và SPRING BOOT?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#16difference-between-spring-core--spring-boot) |
| 17             |[REST API? Lợi ích của việc sử dụng JSON so với XML là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/edit/master/README.md#17rest-api-whats-the-benefit-of-using-json-over-xml) |
| 18             |[Các phương thức khác nhau của quản lý session trong servlets là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#18what-are-the-different-methods-of-session-management-in-servlets) |
| 19             |[Hãy nói về các nguyên tắc thiết kế SOLID. Bạn có thể nhanh chóng giải thích các nguyên tắc thiết kế chính trong dự án hiện tại không?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#19-lets-talk-about-solid-design-principles-could-you-quickly-explain-what-are-the-main-design-principles-in-the-current-project) |
| 20             |[Sự khác biệt giữa wait và notify() trong Java?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#20difference-between-wait-and-notify-work-in-java) |
| 21             |[Các phạm vi khác nhau của biến java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#21what-are-different-scopes-of-java-variable) |
| 22             |[Bạn đọc dữ liệu từ một tệp phẳng trong java như thế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#22how-do-you-read-data-from-a-flat-file-in-java) |
| 23             |[Synchronization có nghĩa là gì trong bối cảnh đa luồng?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#23what-is-synchronization-with-respect-to-multithreading) |
| 24             |[Iterator là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#24what-is-an-iterator) |
| 25             |[Bạn làm thế nào để ngăn ai đó ghi đè một phương thức trong một lớp bạn viết?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#25how-do-you-prevent-someone-from-overriding-a-method-in-a-class-you-write) |
| 26             |[Java xử lý việc tràn và thiếu như thế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#26how-does-java-handle-introducing-overflows-and-underflows) |
| 27             |[Giá trị mặc định của một biến cục bộ là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#27what-is-the-default-value-of-a-local-variable) |
| 28             |[Nếu một phương thức hoặc trường là static thì có nghĩa là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#28what-does-it-mean-if-a-method-or-field-is-static) |
| 29             |[Bạn sẽ thêm nhận xét vào mã java của mình như thế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#29how-would-you-put-comments-in-your-java-code) |
| 30             |[Sự khác biệt giữa string và string buffer là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#30what-is-the-difference-between-string-and-string-buffer) |
| 31             |[J2EE là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#31what-is-j2ee) |
| 32             |[Message driven bean là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#32what-is-a-message-driven-bean) |
| 33             |[Entity Bean là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#33what-is-entity-bean) |
| 34             |[Các phương thức callback trong J2EE là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#34what-are-call-back-methods-in-j2ee) |
| 35             |[Mô-đun ứng dụng khách trong J2EE là gì? Cho một ví dụ?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#35what-is-an-application-client-module-in-j2ee-give-an-example) |
| 36             |[Deployment descriptor là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#36what-is-a-deployment-descriptor) |
| 37             |[Mức độ cách ly giao dịch là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#37what-is-the-transaction-isolation-level) |
| 38             |[Microservices là gì và các dịch vụ nào tạo nên microservices và điều gì làm cho nó trở thành một microservice tốt?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#38what-are-microservices-and-what-are-the-services-that-make-a-microservices-and-what-makes-it-a-good-one) |
| 39             |[Định nghĩa của bạn về Microservices là gì? Điều gì làm cho một cái gì đó trở thành Microservice?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#39what-is-the-definition-of-microservices-according-to-you-what-makes-something-a-microservice) |
| 40             |[Từ khóa volatile là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#40what-are-volatile-keywords) |
| 41             |[Bạn có thể giải thích kinh nghiệm gần đây về việc xây dựng một API không?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#41can-you-explain-recent-experience-on-building-an-api) |
| 42             |[Giải thích lợi ích của Dynamo DB?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#42please-explain-dynamo-db-advantages) |
| 43             |[Bạn có thể giải thích việc sử dụng Kotlin không?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#43can-you-explain-the-usage-of-kotlin) |
| 44             |[Bạn đã làm việc với Lambda trong AWS chưa?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#44have-you-worked-for-lambda-in-aws) |
| 45             |[Bạn sẽ viết một lớp Java có thể kiểm tra được như thế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#45how-would-you-write-a-java-class-that-is-testable) |
| 46             |[Bạn có thể giải thích việc rút ngắn URL không?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#46can-you-explain-url-shortening) |
| 47             |[Giải thích chiến lược caching?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#47explain-caching-strategy) |
| 48             |[Định nghĩa SDN networking?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#48please-define-sdn-networking) |
| 49             |[Lập trình đa luồng là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#49what-is-multi-thread-programming) |
| 50             |[ReadWriteLocks là gì? Bạn sẽ sử dụng thiết kế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#50what-is-readwritelocks-what-design-will-you-use) |
| 51             |[Giải thích JAVA - Cấu trúc dữ liệu?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#51please-explain-java---data-structures) |
| 52             |[Các cấu trúc dữ liệu quen thuộc mà bạn đã sử dụng trong java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#52-what-are-the-familiar-data-structures-you-used-in-java) |
| 53             |[Hashmap hoạt động như thế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#53how-does-hashmap-work) |
| 54             |[Giải thích concurrent hashmap? Và tại sao chúng ta cần một concurrent hashmap?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#54explain-concurrent-hashmap-and-why-do-we-need-a-concurrent-hashmap) |
| 55             |[Sự khác biệt giữa docker và máy ảo là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#55what-is-the-difference-between-docker-vs-virtual-machine) |
| 56             |[Khi bạn làm microservices, chúng ta có nhiều microservices và có sự khác biệt về ưu và nhược điểm?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#56when-you-do-the-microservices-we-have-multiple-microservices-and-there-are-difference-pros-and-cons) |
| 57             |[Trạng thái đóng, trạng thái mở là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#57what-is-closed-state-open-state) |
| 58             |[Hystrix là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#58what-is-hystrix) |
| 59             |[Cho tôi biết sự khác biệt giữa hash key và sort key trong dynamodb?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#59tell-me-the-difference-between-hash-key-and-sort-key-in-dynamodb) |
| 60             |[Sự khác biệt giữa danh sách và bảng băm là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#60what-is-the-difference-between-list-and-hash-table) |
| 61             |[Bạn đang cố gắng lưu trữ thông tin của mọi người trong một bảng băm. Bạn sẽ thiết kế khóa của mình như thế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#61youre-trying-to-store-peoples-info-in-a-hash-table-how-would-you-design-your-key) |
| 62             |[Từ khóa synchronized là gì và có những cách sử dụng khác nhau nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#62-what-is-the-synchronized-keyword-and-what-are-the-different-ways-to-use-synchronized-keywords) |
| 63             |[Khối synchronized là gì? Sự khác biệt giữa khối synchronized và phương thức synchronized là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#63what-is-a-synchronized-block-what-is-the-difference-between-synchronized-block-and-synchronized-method) |
| 64             |[Giải thích về các bộ tích lũy đồng thời? Và Tính đồng thời trong java?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#64-explain-concurrent-accumulators--and-concurrency-in-java) |
| 65             |[Các bộ tích lũy đồng thời trong java?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#65concurrent-accumulators-in-java) |
| 66             |[Sự khác biệt giữa lưu trữ nóng và lưu trữ lạnh là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#66-difference-between-hot-storage-vs-cold-storage) |
| 67             |[Lớp trừu tượng trong java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#67-what-is-an-abstract-class-in-java) |
| 68             |[Interface là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#68-what-is-the-interface) |
| 69             |[Sử dụng của equals trong JAVA?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#69-use-of-equals-in-java) |
| 70             |[EKS là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#70-what-is-eks) |
| 71             |[EKS hoạt động như thế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#71how-does-eks-work) |
| 72             |[Bạn chạy lệnh nào trên EKS?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#72what-commands-do-you-run-eks) |
| 73             |[Versioning là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#73what-is-versioning) |
| 74             |[Bạn có ý nghĩa gì khi nói về vòng đời của một thread?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#74-what-do-you-mean-by-the-life-cycle-of-a-thread) |
| 75             |["Versioning of objects" có nghĩa là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#75-what-does-versioning-of-objects-mean) |
| 76             |[Sự khác biệt giữa rest và soap là gì? Cái nào an toàn hơn: rest hay soap?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#76-difference-between-rest-and-soap-which-is-more-secure-rest-or-soap) |
| 77             |[Sự khác biệt giữa compute và Kubernetes engine là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#77-difference-between-compute-and-kubernetes-engine) |
| 78             |[Sự khác biệt giữa @component và @bean là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#78-difference-between-component--bean) |
| 79             |[Cho tôi biết lợi ích của việc sử dụng biểu thức lambda Java 8 là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#79-tell-me-the-benefit-of-using-java8-lambda-expressions) |
| 80             |[Predicate trong java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#80-what-is-a-predicate-in-java) |
| 81             |[Làm thế nào để tạo một lớp singleton?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#81-how-to-create-a-singleton-class) |
| 82             |[Bạn có biết về marker interface không?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#82-do-you-know-the-marker-interface) |
| 83             |[Khi nào bạn sử dụng serialization?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#83-when-do-you-use-serialization) |
| 84             |[Materialized view trong java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#84-what-is-a-materialized-view-in-java) |
| 85             |[NFR là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#85-what-is-nfr) |
| 86             |[Resiliency trong java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#86-what-is-the-resiliency-in-java) |
| 87             |[Giải thích về mẫu circuit breaker?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#87-explain-the-circuit-breaker-pattern) |
| 88             |[Trong java bạn đã sử dụng bất kỳ mẫu thiết kế nào chưa?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#88-in-java-have-you-used-any-design-patterns) |
| 89             |[Các cách khác nhau để tạo một thread là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#89-what-are-the-different-ways-to-create-a-thread) |
| 90             |[Annotation Spring là gì? Vui lòng đưa ra ví dụ?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#90-what-is-spring-annotation-please-give-examples-too) |
| 91             |[Splunk là gì? Các bản ghi sẽ đến Splunk như thế nào?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#91-what-is-splunk-how-will-logs-come-in-splunk) |
| 92             |[Mẫu Resiliency trong Java là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#92-what-is-the-resiliency-pattern-in-java) |
| 93             |[Mẫu circuit breaker là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#93-what-is-the-circuit-breaker-pattern) |
| 94             |[Hibernate criteria builder là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#94-what-is-a-hibernate-criteria-builder) |
| 95             |[Sự khác biệt giữa put và patch là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#95-what-is-the-difference-between-put-and-patch) |
| 96             |[Java Streams là gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#96-what-are-java-streams) |
| 97             |[Tại sao các biến trong interface lại là public, static, final?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#97-why-variables-in-interface-are-public-static-final) |
| 98             |[Tại sao các biến trong interface không cần phải khai báo trong các lớp triển khai?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#98-why-variables-in-interface-dont-need-to-declare-in-implementing-classes) |
| 99             |[Điều gì sẽ xảy ra nếu bạn đặt câu lệnh return hoặc System.exit() trong khối try hoặc catch? Khối finally có thực thi không?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#99-what-will-happen-if-you-put-return-statement-or-systemexit--on-try-or-catch-block-will-finally-block-execute) |
| 100             |[Bạn có thể ghi đè một phương thức private hoặc static trong Java không?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#100-can-you-override-a-private-or-static-method-in-java) |
| 101             |[Chương trình Java sau đây in ra cái gì?](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#101-what-does-the-following-java-program-print) |


**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 1. Các tính năng mới của Java 8

Java 8 cung cấp các tính năng sau cho lập trình Java:
*	Các biểu thức lambda - Thêm khả năng xử lý hàm vào Java. 
*	Tham chiếu phương thức - Tham chiếu các hàm bằng tên của chúng thay vì gọi trực tiếp. Sử dụng các hàm như tham số. 
*	Các interface chức năng,
*	Stream API - API stream mới để tạo điều kiện cho việc xử lý pipeline. 
*	Các phương thức mặc định,
*	Mã hóa và giải mã Base64,
*	Các phương thức tĩnh trong interface,
*	Lớp Optional,
*	Lớp Collectors,
*	Phương thức ForEach(),
*	+36
*	Sắp xếp mảng song song,
*	Nashorn JavaScript Engine - Một engine dựa trên Java để thực thi mã JavaScript. 
*	Sắp xếp mảng song song,
*	Các loại và chú thích lặp lại,
*	Cải tiến IO,
*	Cải tiến đồng thời,
*	Cải tiến JDBC, v.v.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 2. Sự khác biệt giữa phương thức GET và POST?

| GET        | POST      | 
| ------------- |-------------| 
|Số lượng dữ liệu gửi đi bị giới hạn vì dữ liệu được gửi trong header.|Số lượng dữ liệu lớn có thể được gửi vì dữ liệu được gửi trong body.|
|Không an toàn vì dữ liệu được hiển thị trong thanh URL.|An toàn vì dữ liệu không được hiển thị trong thanh URL.|
|Có thể được đánh dấu trang|Không thể được đánh dấu trang|
|Idempotent|Không Idempotent|
|Hiệu quả hơn và được sử dụng nhiều hơn Post|Ít hiệu quả hơn và ít được sử dụng|

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 3. Sự khác biệt giữa phương thức forward() và phương thức SendRedirect()?

| Phương thức forward()        | Phương thức sendRedirect()      | 
| ------------- |-------------| 
|forward() gửi cùng một yêu cầu đến một tài nguyên khác.|phương thức sendRedirect() luôn gửi yêu cầu mới vì nó sử dụng thanh URL của trình duyệt.|
|Phương thức forward() hoạt động ở phía máy chủ.|phương thức sendRedirect() hoạt động ở phía khách hàng.|
|Phương thức forward() chỉ hoạt động trong máy chủ.|phương thức sendRedirect() hoạt động bên trong và bên ngoài máy chủ.|

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 4. Sự khác biệt giữa HashMap và HashTable?

| HashMap        | HashTable      | 
| ------------- |-------------| 
|Các phương thức không được đồng bộ hóa|Các phương thức khóa là đồng bộ hóa|
|Không an toàn cho luồng|An toàn cho luồng|
|Iterator được sử dụng để lặp qua các giá trị|Enumerator được sử dụng để lặp qua các giá trị|
|Cho phép một khóa null và nhiều giá trị null|Không cho phép bất kỳ thứ gì là null|
|Hiệu suất cao hơn HashTable|Hiệu suất chậm hơn|

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 5. Sự khác biệt giữa HashSet và TreeSet?

| HashSet        | TreeSet      | 
| ------------- |-------------| 
|Các phần tử được chèn vào theo thứ tự ngẫu nhiên|Duy trì các phần tử theo thứ tự đã sắp xếp|
|Có thể lưu trữ các đối tượng null|Không thể lưu trữ các đối tượng null|
|Hiệu suất nhanh|Hiệu suất chậm|

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 6. Collections trong Java có nghĩa là gì?

Collection trong Java là một framework cung cấp một kiến trúc để lưu trữ và thao tác với nhóm các đối tượng. Java Collections có thể thực hiện tất cả các thao tác mà bạn thực hiện trên dữ liệu như tìm kiếm, sắp xếp, chèn, thao tác và xóa. Java Collection có nghĩa là một đơn vị duy nhất của các đối tượng. Framework Java Collection cung cấp nhiều interface (Set, List, Queue, Deque) và các lớp (ArrayList, Vector, LinkedList, PriorityQueue, HashSet, LinkedHashSet, TreeSet). 

Collections được sử dụng để thực hiện các thao tác sau:
*	Tìm kiếm
*	Sắp xếp
*	Thao tác
*	Chèn
*	Xóa 

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 7. Ordered và Sorted trong collections có nghĩa là gì?

**Ordered:**

Có nghĩa là các giá trị được lưu trữ trong một collection dựa trên các giá trị được thêm vào collection. Vì vậy, chúng ta có thể lặp qua các giá trị từ collection theo một thứ tự cụ thể.

**Sorted:**

Cơ chế sắp xếp có thể được áp dụng bên trong hoặc bên ngoài để nhóm các đối tượng được sắp xếp trong một collection cụ thể dựa trên các thuộc tính của các đối tượng.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 8. Giải thích về Set và các loại của nó trong một collection?

**Set**

Set quan tâm đến tính duy nhất. Nó không cho phép các bản sao. Ở đây phương thức “equals ( )” được sử dụng để xác định xem hai đối tượng có giống nhau hay không.

**Hash Set:**
*	Không có thứ tự và không được sắp xếp.
*	Sử dụng mã băm của đối tượng để chèn các giá trị.
*	Sử dụng điều này khi yêu cầu là “không có bản sao và không quan tâm đến thứ tự”.

Ví dụ:
```java
public class Fruit {
  public static void main (String[] args){
    HashSet<String> names = new HashSet<String>();
    names.add("banana");
    names.add("cherry");
    names.add("apple");
    names.add("kiwi");
    names.add("banana");
    System.out.println(names);
  }
}
```
Đầu ra:

[banana, cherry, kiwi, apple]

Không theo bất kỳ thứ tự chèn nào. Các bản sao không được phép.

**Linked Hash set:**
*	Một phiên bản có thứ tự của hash set được gọi là Linked Hash Set.
*	Duy trì một danh sách liên kết đôi của tất cả các phần tử.
*	Sử dụng điều này khi yêu cầu thứ tự lặp lại.

Ví dụ:
```java
public class Fruit {
  public static void main (String[] args){
    LinkedHashSet<String> names = new LinkedHashSet<String>();
    names.add("banana");
    names.add("cherry");
    names.add("apple");
    names.add("kiwi");
    names.add("banana");
    System.out.println(names);
  }
}
```
Đầu ra:

[banana, cherry, apple, kiwi]

Duy trì thứ tự chèn mà chúng đã được thêm vào Set. Các bản sao không được phép.

**Tree Set:**
*	Nó là một trong hai collection được sắp xếp.
*	Sử dụng cấu trúc cây “Read-Black” và đảm bảo rằng các phần tử sẽ được sắp xếp theo thứ tự tăng dần.
*	Chúng ta có thể xây dựng một tree set với constructor bằng cách sử dụng comparable (hoặc) comparator.

Ví dụ:
```java
public class Fruits{
  public static void main (String[] args) {
    TreeSet<String> names= new TreeSet<String>();
    names.add("cherry");
    names.add("banana");
    names.add("apple");
    names.add("kiwi");
    names.add("cherry");
    System.out.println(names);
  }
}
```
Đầu ra:

[apple, banana, cherry, kiwi]

TreeSet sắp xếp các phần tử theo thứ tự tăng dần. Và các bản sao không được phép.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 9. Từ khóa final trong Java là gì?

**Biến final:**

Khi một biến được khai báo là final, thì giá trị của biến không thể thay đổi. Nó giống như một hằng số.

Ví dụ:
```java
final int x = 12;
```
**Phương thức final:**

Một từ khóa final trong một phương thức không thể bị ghi đè. Nếu một phương thức được đánh dấu là final, thì nó không thể bị ghi đè bởi lớp con.

**Lớp final:**

Nếu một lớp được khai báo là final, thì lớp đó không thể được kế thừa. Không có lớp nào có thể mở rộng/kế thừa lớp final.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 10. Thread là gì?

Trong Java, luồng thực thi được gọi là Thread. Mỗi chương trình java có ít nhất một thread gọi là main thread, thread chính được tạo bởi JVM. Người dùng có thể định nghĩa các thread của riêng họ bằng cách mở rộng lớp Thread (hoặc) bằng cách triển khai interface Runnable. Các thread được thực thi đồng thời.

Ví dụ:
```java
public static void main(String[] args){//main thread starts here

}
```

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 11. Giải thích vòng đời của thread trong Java

Thread có các trạng thái sau:
*	Mới
*	Có thể chạy
*	Đang chạy
*	Không thể chạy (Bị chặn)
*	Đã kết thúc

![Vòng đời của Thread](https://user-images.githubusercontent.com/649439/167628356-49e0a73f-d0d9-47ce-a643-5288e068a060.png)


*	**Mới:** Trong trạng thái Mới, instance Thread đã được tạo nhưng phương thức start() chưa được gọi. Bây giờ thread không được coi là sống.
*	**Có thể chạy:** Thread ở trạng thái có thể chạy sau khi gọi phương thức start(), nhưng trước khi phương thức run() được gọi. Nhưng một thread cũng có thể quay lại trạng thái có thể chạy từ đang chờ/ngủ. Trong trạng thái này, thread được coi là sống.
*	**Đang chạy:** Thread ở trạng thái đang chạy sau khi nó gọi phương thức run(). Bây giờ thread bắt đầu thực thi.
*	**Không thể chạy (Bị chặn):** Thread đang sống nhưng không đủ điều kiện để chạy. Nó không ở trạng thái có thể chạy nhưng cũng sẽ quay lại trạng thái có thể chạy sau một thời gian. Ví dụ: chờ, ngủ, bị chặn.
*	**Đã kết thúc:** Khi phương thức run hoàn thành, nó sẽ bị kết thúc. Bây giờ thread không còn sống.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 12. Các phương thức nào được sử dụng trong quá trình Serialization và Deserialization?

Các lớp ObjectOutputStream và ObjectInputStream là các lớp cao cấp trong gói java.io. Chúng ta sẽ sử dụng chúng với các lớp cấp thấp hơn là FileOutputStream và FileInputStream.

ObjectOutputStream.writeObject —-> Serialize đối tượng và ghi đối tượng đã được serialize vào một tệp.

ObjectInputStream.readObject —> Đọc tệp và deserializes đối tượng.

Để được serialize, một đối tượng phải triển khai interface serializable. Nếu một lớp cha triển khai Serializable, thì lớp con sẽ tự động được serialize.

| Serialization        | Deserialization      | 
| ------------- |-------------|
|Serialization là quá trình được sử dụng để chuyển đổi các đối tượng thành dòng byte|Deserialization là quá trình ngược lại của serialization, nơi chúng ta có thể lấy lại các đối tượng từ dòng byte.|
|Một đối tượng được serialize bằng cách ghi nó vào một ObjectOutputStream.|Một đối tượng được deserialized bằng cách đọc nó từ một ObjectInputStream.|

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 13. Khi nào sử dụng interface Runnable so với lớp Thread trong Java?

Nếu chúng ta cần lớp của mình mở rộng một số lớp khác ngoài thread thì chúng ta có thể sử dụng interface runnable vì trong java chúng ta chỉ có thể mở rộng một lớp. Nếu chúng ta không có ý định mở rộng bất kỳ lớp nào thì chúng ta có thể mở rộng lớp thread.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 14. Vòng đời của một servlet là gì?

Có 5 giai đoạn trong vòng đời của một servlet:

1.	Servlet được tải
2.	Servlet được khởi tạo
3.	Servlet được khởi tạo
4.	Xử lý yêu cầu
5.	Servlet bị hủy

![image](https://user-images.githubusercontent.com/649439/167629455-326556a3-d24c-4c28-88de-c16a40b946de.png)

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 15. Sự khác biệt giữa ServletContext và ServletConfig?

| ServletConfig        | ServletContext      | 
| ------------- |-------------|
|Đối tượng servlet config đại diện cho một servlet duy nhất|Nó đại diện cho toàn bộ ứng dụng web đang chạy trên JVM cụ thể và chung cho tất cả các servlet|
|Nó giống như tham số cục bộ liên quan đến servlet cụ thể|Nó giống như tham số toàn cầu liên quan đến toàn bộ ứng dụng|
|Nó là một cặp tên giá trị được định nghĩa bên trong phần servlet của tệp web.xml, vì vậy nó có phạm vi toàn servlet|ServletContext có phạm vi toàn ứng dụng, vì vậy được định nghĩa bên ngoài thẻ servlet trong tệp web.xml.|
|phương thức getServletConfig() được sử dụng để lấy đối tượng config|phương thức getServletContext() được sử dụng để lấy đối tượng context.|
|Ví dụ, giỏ hàng của một người dùng là cụ thể cho người dùng đó, vì vậy ở đây chúng ta có thể sử dụng servlet config|Để lấy loại MIME của một tệp hoặc thông tin liên quan đến phiên ứng dụng được lưu trữ bằng đối tượng servlet context.|

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 16. Sự khác biệt giữa SPRING CORE và SPRING BOOT?

**Spring Framework:**
*	Spring là một trong những framework Java EE được sử dụng rộng rãi nhất để xây dựng ứng dụng. 
*	Đối với nền tảng Java, framework Spring cung cấp một mô hình lập trình và cấu hình chi tiết. 
*	Nó nhằm mục đích đơn giản hóa việc phát triển Java EE và giúp các nhà phát triển làm việc hiệu quả hơn. 
*	Nó có thể được sử dụng trên bất kỳ nền tảng triển khai nào.
*	Một trong những tính năng chính của framework Spring là tiêm phụ thuộc. 
*	Nó giúp đơn giản hóa mọi thứ bằng cách cho phép chúng ta phát triển các ứng dụng lỏng lẻo.

**Spring Boot:**
*	Khi framework Spring tập trung vào việc cung cấp sự linh hoạt cho bạn, Spring Boot nhằm mục đích rút ngắn độ dài mã và cung cấp cho bạn cách dễ nhất để phát triển một ứng dụng web. 
*	Với cấu hình chú thích và mã mặc định, Spring Boot rút ngắn thời gian phát triển ứng dụng. 
*	Nó giúp tạo ra một ứng dụng độc lập với ít hoặc gần như không cần cấu hình.
*	Tự động cấu hình là một tính năng đặc biệt trong Spring Boot. 
*	Nó tự động cấu hình một lớp dựa trên yêu cầu đó.


| Spring        | Spring Boot      | 
| ------------- |-------------|
|Spring Framework là một framework Java EE được sử dụng rộng rãi để xây dựng ứng dụng.|Spring Boot Framework được sử dụng rộng rãi để phát triển REST APIs.|
|Nó nhằm mục đích đơn giản hóa việc phát triển Java EE, giúp các nhà phát triển làm việc hiệu quả hơn.|Nó nhằm mục đích rút ngắn độ dài mã và cung cấp cách dễ nhất để phát triển ứng dụng web.|
|Tính năng chính của Spring Framework là tiêm phụ thuộc.|Tính năng chính của Spring Boot là Tự động cấu hình. Nó tự động cấu hình các lớp dựa trên yêu cầu.|
|Nó giúp đơn giản hóa mọi thứ bằng cách cho phép chúng ta phát triển các ứng dụng lỏng lẻo.|Nó giúp tạo ra một ứng dụng độc lập với ít cấu hình.|
|Nhà phát triển viết nhiều mã (mã boilerplate) để thực hiện nhiệm vụ tối thiểu.|Nó giảm mã boilerplate.|
|Để kiểm tra dự án Spring, chúng ta cần thiết lập máy chủ một cách rõ ràng.|Để kiểm tra dự án Spring, chúng ta cần thiết lập máy chủ một cách rõ ràng.|
|Nó không cung cấp hỗ trợ cho cơ sở dữ liệu trong bộ nhớ.|Nó cung cấp nhiều plugin để làm việc với cơ sở dữ liệu nhúng và trong bộ nhớ như H2.|
|Các nhà phát triển định nghĩa thủ công các phụ thuộc cho dự án Spring trong tệp pom.xml.|Spring Boot đi kèm với khái niệm starter trong tệp pom.xml mà nội bộ chăm sóc việc tải xuống các tệp JAR phụ thuộc dựa trên yêu cầu của Spring Boot.|
|Spring là một framework nhẹ mã nguồn mở được sử dụng rộng rãi để phát triển các ứng dụng doanh nghiệp.|Spring Boot được xây dựng trên top của framework spring truyền thống, được sử dụng rộng rãi để phát triển REST APIs.|

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 17. REST API? Lợi ích của việc sử dụng JSON so với XML là gì?

**REST API :- ** 

*	REST là viết tắt của transfer trạng thái đại diện.
*	Một REST API (còn được gọi là RESTful API) là một giao diện lập trình ứng dụng (API hoặc web API) tuân thủ các ràng buộc của phong cách kiến trúc REST và cho phép tương tác với các dịch vụ web RESTful.  
*	Một API là một tập hợp các định nghĩa và giao thức để xây dựng và tích hợp phần mềm ứng dụng.  
*	Nó đôi khi được gọi là một hợp đồng giữa nhà cung cấp thông tin và người sử dụng thông tin—thiết lập nội dung cần thiết từ người tiêu dùng (cuộc gọi) và nội dung cần thiết bởi nhà sản xuất (phản hồi). 
*	Khi một yêu cầu của khách hàng được thực hiện thông qua một RESTful API, nó chuyển giao một đại diện của trạng thái của tài nguyên đến người yêu cầu hoặc điểm cuối. 
*	Thông tin này, hoặc đại diện, được chuyển giao trong một trong một số định dạng qua HTTP: JSON (Javascript Object Notation), HTML, XLT, Python, PHP hoặc văn bản thuần túy. 

**Lợi ích của việc sử dụng JSON so với XML :- **
*	Giảm độ dài: JSON có phong cách gọn gàng hơn so với XML, và thường dễ đọc hơn. Cách tiếp cận nhẹ của JSON có thể cải thiện đáng kể trong các API RESTful làm việc với các hệ thống phức tạp.
*	Nhanh hơn: Quá trình phân tích cú pháp phần mềm XML có thể mất nhiều thời gian. Một lý do cho vấn đề này là các thư viện thao tác DOM yêu cầu nhiều bộ nhớ hơn để xử lý các tệp XML lớn. JSON sử dụng ít dữ liệu tổng thể hơn, vì vậy bạn giảm chi phí và tăng tốc độ phân tích cú pháp.
*	Dễ đọc: Cấu trúc JSON rất đơn giản và dễ đọc. Bạn có thời gian dễ dàng hơn để ánh xạ đến các đối tượng miền, bất kể ngôn ngữ lập trình nào bạn đang làm việc.
*	Cấu trúc phù hợp với dữ liệu: JSON sử dụng cấu trúc dữ liệu bản đồ thay vì cây của XML. Trong một số tình huống, các cặp khóa/giá trị có thể giới hạn những gì bạn có thể làm, nhưng bạn có một mô hình dữ liệu dễ hiểu và dễ dự đoán.
*	Các đối tượng phù hợp trong mã: Các đối tượng JSON và các đối tượng mã khớp nhau, điều này có lợi khi nhanh chóng tạo các đối tượng miền trong các ngôn ngữ động.
*	Hạn chế của JSON: Các hạn chế trong JSON thực sự trở thành một trong những lợi ích lớn nhất của nó. Một dòng suy nghĩ phổ biến giữa các nhà phát triển là XML vượt trội hơn vì nó hỗ trợ mô hình hóa nhiều đối tượng hơn. Tuy nhiên, các hạn chế của JSON đơn giản hóa mã, thêm tính dự đoán và tăng tính dễ đọc.

So với mô hình XML, cấu trúc dữ liệu JSON rất trực quan, giúp dễ đọc và ánh xạ trực tiếp đến các đối tượng miền trong bất kỳ ngôn ngữ lập trình nào đang được sử dụng. 

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 18. Các phương thức khác nhau của quản lý session trong servlets là gì?

Session là một trạng thái hội thoại giữa khách hàng và máy chủ và nó có thể bao gồm nhiều yêu cầu và phản hồi giữa khách hàng và máy chủ. Vì HTTP và Web Server đều không có trạng thái, cách duy nhất để duy trì một phiên là khi một số thông tin duy nhất về phiên (session id) được truyền giữa máy chủ và khách hàng trong mỗi yêu cầu và phản hồi.

Một số cách phổ biến của quản lý session trong servlets là:
1.	Xác thực người dùng
2.	Trường ẩn HTML
3.	Cookies
4.	Viết lại URL
5.	API quản lý phiên

![image](https://user-images.githubusercontent.com/649439/167678579-d7277e08-3154-479c-bfdf-f36a63af646e.png)

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 19. Hãy nói về các nguyên tắc thiết kế SOLID. Bạn có thể nhanh chóng giải thích các nguyên tắc thiết kế chính trong dự án hiện tại không?

**Các nguyên tắc SOLID** xuất phát từ một bài tiểu luận được viết vào năm 2000 bởi Robert Martin, được biết đến với tên gọi Uncle Bob, nơi ông thảo luận rằng một ứng dụng thành công sẽ thay đổi và, nếu không có thiết kế tốt, có thể trở nên cứng nhắc, dễ vỡ, không di động và nhớt.

**Cứng nhắc —** Mọi thứ rất cố định. Bạn không thể di chuyển hoặc thay đổi mọi thứ mà không ảnh hưởng đến những thứ khác, nhưng rõ ràng điều gì sẽ bị hỏng nếu bạn thực hiện một thay đổi.

**Dễ vỡ —** Dễ dàng di chuyển và thay đổi mọi thứ nhưng không rõ điều gì khác có thể bị hỏng như một kết quả.

**Không di động —** Mã hoạt động tốt nhưng bạn không thể tái sử dụng mã mà không sao chép hoặc nhân bản nó.

**Nhớt —** Mọi thứ sụp đổ khi bạn thực hiện một thay đổi, bạn nhanh chóng đẩy nó lại với nhau và làm cho thay đổi của bạn hoạt động. Điều tương tự xảy ra khi người khác đến để thực hiện một thay đổi.

**Các Nguyên Tắc SOLID -**

**S — Trách nhiệm đơn lẻ:**
- Một lớp nên có một trách nhiệm duy nhất.
- ‘Không bao giờ nên có nhiều hơn một lý do để một lớp thay đổi’.

**O — Mở-Đóng**
- Các lớp nên mở cho việc mở rộng, nhưng đóng cho việc sửa đổi.
- ‘Một mô-đun nên mở cho việc mở rộng nhưng đóng cho việc sửa đổi’.

**L — Thay thế Liskov**
- Nếu S là một kiểu con của T, thì các đối tượng kiểu T trong một chương trình có thể được thay thế bằng các đối tượng kiểu S mà không làm thay đổi bất kỳ thuộc tính mong muốn nào của chương trình đó.
- ‘Các lớp con nên có thể thay thế cho các lớp cơ sở của chúng’.

**I — Phân tách giao diện**
- Các khách hàng không nên bị buộc phải phụ thuộc vào các phương thức mà họ không sử dụng.
- ‘Nhiều giao diện cụ thể cho khách hàng thì tốt hơn một giao diện đa năng’.

**D — Đảo ngược phụ thuộc**
- Các mô-đun cấp cao không nên phụ thuộc vào các mô-đun cấp thấp. Cả hai đều nên phụ thuộc vào sự trừu tượng.
- Các trừu tượng không nên phụ thuộc vào các chi tiết. Các chi tiết nên phụ thuộc vào các trừu tượng.
- ‘Phụ thuộc vào các trừu tượng. Đừng phụ thuộc vào các cụ thể.’

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 20. Sự khác biệt giữa wait() và notify() trong Java?

| wait()        | notify()      | 
| ------------- |-------------|
|Khi wait() được gọi trên một thread đang giữ khóa monitor, nó từ bỏ khóa monitor và vào trạng thái chờ.|Khi notify() được gọi trên một thread đang giữ khóa monitor, nó biểu thị rằng thread đó sắp từ bỏ khóa. Cú pháp: ```public final void notify()``` |
|Có thể có nhiều thread trong trạng thái chờ cùng một lúc.|Một trong các thread đang chờ được chọn ngẫu nhiên và được thông báo về điều đó. Thread được thông báo sau đó thoát khỏi trạng thái chờ và vào trạng thái bị chặn nơi nó chờ cho đến khi thread trước đó từ bỏ khóa và thread này đã chiếm được nó. Khi nó chiếm được khóa, nó vào trạng thái có thể chạy nơi nó chờ thời gian CPU và sau đó bắt đầu chạy.|
|Object.wait() để tạm dừng một thread|Object.notify() để đánh thức một thread|
|Gây ra thread hiện tại giải phóng khóa và chờ cho đến khi một thread khác gọi phương thức notify() hoặc phương thức notifyAll() cho đối tượng này, hoặc một khoảng thời gian xác định đã trôi qua.|Đánh thức một thread duy nhất đang chờ trên monitor của đối tượng này. Nếu bất kỳ thread nào đang chờ trên đối tượng này, một trong số chúng được chọn để được đánh thức. Sự lựa chọn là tùy ý và xảy ra theo sự quyết định của việc thực hiện.|

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 21. Các phạm vi khác nhau của biến java là gì?

Java cung cấp một số modifier truy cập để thiết lập mức độ truy cập cho các lớp, biến, phương thức và constructor. 

Bốn mức độ truy cập là -
●	Có thể nhìn thấy trong gói, mặc định. Không cần modifier.
●	Có thể nhìn thấy chỉ trong lớp (private).
●	Có thể nhìn thấy với mọi người (public).
●	Có thể nhìn thấy trong gói và tất cả các lớp con (protected).
●	Các biến lớp (tĩnh), biến thể hiện và biến phương thức (cục bộ)

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 22. Bạn đọc dữ liệu từ một tệp phẳng trong java như thế nào?

Buffered Reader, Scanner, Files, FileReader

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 23. Synchronization có nghĩa là gì trong bối cảnh đa luồng?

Trong bối cảnh đa luồng, synchronization là khả năng kiểm soát quyền truy cập của nhiều thread đến các tài nguyên chia sẻ. Nếu không có synchronization, có thể một thread sửa đổi một biến chia sẻ trong khi một thread khác đang sử dụng hoặc cập nhật cùng một biến chia sẻ.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 24. Iterator là gì?

Một Iterator là một đối tượng có thể được sử dụng để lặp qua các collection, như ArrayList và HashSet. 

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 25. Bạn làm thế nào để ngăn ai đó ghi đè một phương thức trong một lớp bạn viết?

private, static và final

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 26. Java xử lý việc tràn và thiếu như thế nào?

Nếu nó tràn, nó quay lại giá trị tối thiểu và tiếp tục từ đó. Nếu nó thiếu, nó quay lại giá trị tối đa và tiếp tục từ đó.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 27. Giá trị mặc định của một biến cục bộ là gì?

Không có giá trị mặc định cho các biến cục bộ, vì vậy các biến cục bộ nên được khai báo và một giá trị khởi tạo nên được gán trước khi sử dụng lần đầu tiên.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 28. Nếu một phương thức hoặc trường là static thì có nghĩa là gì?

Bạn không cần instance của lớp để gọi phương thức hoặc trường đó, modifier static có nghĩa là điều gì đó liên quan trực tiếp đến một lớp

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 29. Bạn sẽ thêm nhận xét vào mã java của mình như thế nào?

//  -- một dòng, 
/*  */ -- nhiều dòng

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 30. Sự khác biệt giữa string và string buffer là gì?

Trong ngôn ngữ lập trình Java, các chuỗi được coi như các đối tượng. Nền tảng Java cung cấp lớp String để tạo và thao tác với các chuỗi. Trong khi đó, lớp StringBuffer là một chuỗi ký tự có thể thay đổi và an toàn cho luồng. Một bộ đệm chuỗi giống như một String, nhưng có thể được sửa đổi.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 31. J2EE là gì?

J2EE là một môi trường độc lập nền tảng, tập trung vào Java từ Sun để phát triển, xây dựng và triển khai các ứng dụng doanh nghiệp dựa trên web trực tuyến. Nền tảng J2EE bao gồm một tập hợp các dịch vụ, API và giao thức cung cấp chức năng cho việc phát triển các ứng dụng web đa tầng.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 32. Message driven bean là gì?

Một message-driven bean là một bean doanh nghiệp cho phép các ứng dụng Java EE xử lý tin nhắn một cách không đồng bộ. Loại bean này thường hoạt động như một listener tin nhắn JMS, tương tự như một listener sự kiện nhưng nhận các tin nhắn JMS thay vì sự kiện.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 33. Entity Bean là gì?

Entity bean đại diện cho dữ liệu bền vững được lưu trữ trong cơ sở dữ liệu. Nó là một thành phần phía máy chủ.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 34. Các phương thức callback trong J2EE là gì?

Callback là một cơ chế mà qua đó vòng đời của một bean doanh nghiệp có thể bị chặn. Đặc tả EJB 3.0 đã chỉ định các callback mà các phương thức xử lý callback được tạo ra. Container EJB gọi các callback này. Chúng ta có thể định nghĩa các phương thức callback trong chính lớp EJB hoặc trong một lớp riêng biệt. EJB 3.0 đã cung cấp nhiều chú thích cho các callback.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 35. Mô-đun ứng dụng khách trong J2EE là gì? Cho một ví dụ?

Mô-đun ứng dụng khách: Chứa một mô tả triển khai ứng dụng khách, đó là một tệp XML có phần mở rộng .xml, bên cạnh các tệp lớp, được đóng gói dưới dạng tệp Java Archive (JAR) với phần mở rộng .jar.

Mô-đun Enterprise JavaBeans (EJB): Chứa một mô tả triển khai EJB và các tệp lớp. Mô-đun web: Chứa một mô tả triển khai ứng dụng web, các tệp lớp servlet và các tệp Java Server Pages (JSP). Mô-đun bộ điều hợp tài nguyên: Chứa các interface Java, lớp, thư viện, tài liệu và một mô tả triển khai bộ điều hợp tài nguyên.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 36. Deployment descriptor là gì?

Deployment descriptor là tệp được sử dụng bởi container servlet để xác định các servlet nào phù hợp với các URL nào. Nó cũng xác định servlet hoặc tài nguyên nào cung cấp trang đích cho gốc của dịch vụ.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 37. Mức độ cách ly giao dịch là gì?

Thuộc tính này có nghĩa là mỗi giao dịch được thực hiện trong sự cô lập với các giao dịch khác, và các giao dịch đồng thời không ảnh hưởng đến giao dịch. Mức độ này có thể thay đổi, và như bài viết này sẽ thảo luận, SQL Server có năm mức độ cách ly giao dịch tùy thuộc vào yêu cầu của cơ sở dữ liệu.

JDBC cung cấp hỗ trợ 5 mức độ cách ly giao dịch thông qua interface Connection.

**TRANSACTION_NONE:** Được đại diện bởi giá trị số nguyên 0 không hỗ trợ giao dịch.

**TRANSACTION_READ_COMMITTED:** Được đại diện bởi giá trị số nguyên 2 hỗ trợ giao dịch cho phép các Đọc không lặp lại và các Đọc ảo.

**TRANSACTION_READ_UNCOMMITTED:** Được đại diện bởi giá trị số nguyên 1 hỗ trợ giao dịch cho phép các Đọc bẩn, các Đọc không lặp lại và các Đọc ảo.

**TRANSACTION_REPEATABLE_READ:** Được đại diện bởi giá trị số nguyên 4 hỗ trợ giao dịch chỉ cho phép các Đọc ảo.

**TRANSACTION_SERIALIZABLE:** Được đại diện bởi giá trị số nguyên 8 hỗ trợ giao dịch mà không cho phép các Đọc bẩn, các Đọc không lặp lại và các Đọc ảo.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 38. Microservices là gì và các dịch vụ nào tạo nên microservices và điều gì làm cho nó trở thành một microservice tốt?

Microservice là một phương pháp phát triển ứng dụng dựa trên dịch vụ. Trong phương pháp này, các ứng dụng lớn sẽ được chia thành các đơn vị dịch vụ độc lập nhỏ nhất. 

Microservice là quá trình triển khai Kiến trúc hướng dịch vụ (SOA) bằng cách chia toàn bộ ứng dụng thành một tập hợp các dịch vụ liên kết, nơi mỗi dịch vụ chỉ phục vụ một nhu cầu kinh doanh. Một số tính năng làm cho kiến trúc này trở nên hữu ích hơn:
* Nhỏ về kích thước
* Tập trung
* Tự chủ
* Đa dạng công nghệ
* Độ bền
* Dễ triển khai

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 39. Định nghĩa của bạn về Microservices là gì? Điều gì làm cho một cái gì đó trở thành Microservice?

Microservice là một phương pháp phát triển ứng dụng dựa trên dịch vụ. Trong phương pháp này, các ứng dụng lớn sẽ được chia thành các đơn vị dịch vụ độc lập nhỏ nhất. Microservice là quá trình triển khai Kiến trúc hướng dịch vụ (SOA) bằng cách chia toàn bộ ứng dụng thành một tập hợp các dịch vụ liên kết, nơi mỗi dịch vụ chỉ phục vụ một nhu cầu kinh doanh. 

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 40. Từ khóa volatile là gì? 

Từ khóa volatile được sử dụng để sửa đổi giá trị của một biến bởi các thread khác nhau. Nó cũng được sử dụng để làm cho các lớp an toàn cho luồng. Điều này có nghĩa là nhiều thread có thể sử dụng một phương thức và instance của các lớp cùng một lúc mà không gặp vấn đề gì. Từ khóa volatile có thể được sử dụng với cả các kiểu nguyên thủy hoặc đối tượng. Từ khóa volatile không lưu trữ giá trị của biến và luôn đọc biến từ bộ nhớ chính. Từ khóa volatile không thể được sử dụng với các lớp hoặc phương thức. Tuy nhiên, nó được sử dụng với các biến. Nó cũng đảm bảo tính khả thi và thứ tự. Nó ngăn compiler khỏi việc tái sắp xếp mã.

Nội dung của một thanh ghi thiết bị cụ thể có thể thay đổi bất kỳ lúc nào, vì vậy bạn cần từ khóa volatile để đảm bảo rằng các truy cập như vậy không bị tối ưu hóa bởi compiler.


**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 41. Bạn có thể giải thích kinh nghiệm gần đây về việc xây dựng một API không?  

Có, trước tiên chúng tôi sẽ tạo một controller và trong controller đó chúng tôi sẽ gọi lớp dịch vụ và dịch vụ sẽ gọi lớp DAO, lớp này sẽ tương tác với cơ sở dữ liệu. Chúng tôi sử dụng @RestController để khai báo bất kỳ lớp nào là Rest Controller. Trong lớp này, chúng tôi sẽ viết logic kinh doanh của mình và cùng với đó chúng tôi sẽ triển khai các yêu cầu GET/POST/PUT/DELETE.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 42. Giải thích lợi ích của Dynamo DB?

Lợi ích của DynamoDB cho các hoạt động:
* Hiệu suất và khả năng mở rộng
* Quy tắc kiểm soát truy cập
* Tính bền vững của dữ liệu luồng sự kiện
* Thời gian sống
* Lưu trữ các mục có sơ đồ không nhất quán
* Quản lý dữ liệu tự động

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 43. Bạn có thể giải thích việc sử dụng Kotlin không?

Mặc dù Kotlin là một ngôn ngữ lập trình hàm đầy đủ, nhưng nó vẫn giữ lại hầu hết tính chất hướng đối tượng của Java như một phong cách lập trình thay thế, điều này rất hữu ích khi chuyển đổi mã Java hiện có. Kotlin có các lớp với các constructor, cùng với các lớp lồng, lớp bên trong và lớp bên trong ẩn danh, và nó có các interface như Java 8. Kotlin không có từ khóa new. Để tạo một instance của lớp, chỉ cần gọi constructor như một hàm thông thường. 

Mặc dù Kotlin có thể được sử dụng ở bất kỳ đâu Java được sử dụng (và sớm hơn ở nhiều nơi hơn), nhưng hiện tại nó chủ yếu được sử dụng cho phát triển ứng dụng Android, được thúc đẩy bởi sự hỗ trợ chính thức của Google. Các công ty sử dụng Kotlin để duy trì tính cạnh tranh bao gồm Google, Trello/Atlassian, Pinterest, Kickstarter và Uber, để kể tên một vài.

Lợi ích của Kotlin - 
1. Kotlin cho phép viết ít mã hơn 
2. Nó giải quyết các thách thức của nhà phát triển 
3. Việc áp dụng Kotlin là dễ dàng 
4. Kotlin hoàn toàn tương thích với Java 
5. Nó không gây ra chi phí thời gian chạy 
6. Kotlin có một cộng đồng mạnh mẽ 
7. Kotlin phù hợp cho phát triển đa nền tảng 
8. Phát triển Kotlin cung cấp nhiều độ an toàn hơn 

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 44. Bạn đã làm việc với Lambda trong AWS chưa?

AWS Lambda là một dịch vụ tính toán không máy chủ, dựa trên sự kiện cho phép bạn chạy mã cho hầu như bất kỳ loại ứng dụng hoặc dịch vụ backend nào mà không cần cung cấp hoặc quản lý máy chủ. Bạn có thể kích hoạt Lambda từ hơn 200 dịch vụ AWS và ứng dụng phần mềm như dịch vụ (SaaS), và chỉ trả tiền cho những gì bạn sử dụng.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 45. Bạn sẽ viết một lớp Java có thể kiểm tra được như thế nào?

Viết mã có thể kiểm tra có nghĩa là các thành phần nhỏ nhất có thể được xác minh độc lập. Để làm điều này, mỗi thành phần phải có các phụ thuộc của nó được tiêm vào nó. Điều này có nghĩa là mã không thể tham chiếu đến các biến toàn cầu hoặc sử dụng các singleton đọc/ghi hoặc các bộ định vị dịch vụ, v.v. Điều này có thể là một cách suy nghĩ hơi khác về việc xây dựng một chương trình so với những gì bạn đã quen, nhưng nó có thể là một cách xây dựng phần mềm rất hiệu quả và hiệu quả và nó có thể được xác minh theo cách lập trình.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 46. Bạn có thể giải thích việc rút ngắn URL không?

Một dịch vụ rút ngắn URL là một dịch vụ đơn giản chuyển đổi một URL dài thành một liên kết ngắn. Khi liên kết đó được truy cập, người dùng sẽ được chuyển hướng đến URL gốc. 

Một dịch vụ rút ngắn URL là một dịch vụ được sử dụng để tạo các liên kết ngắn từ các URL rất dài. 

Thông thường, các liên kết ngắn có kích thước bằng một phần ba hoặc thậm chí một phần tư của URL gốc, điều này làm cho chúng dễ dàng hơn để gõ, trình bày hoặc tweet. Khi nhấp vào một liên kết ngắn, người dùng sẽ tự động được chuyển hướng đến URL gốc. 

Có nhiều dịch vụ rút ngắn URL có sẵn trực tuyến, như tiny.cc, bitly.com, cutt.ly, v.v. 

* Mỗi khi dịch vụ rút ngắn URL nhận được một liên kết để rút ngắn, nó lưu liên kết đó vào một Từ điển và trả về một URL ngắn cho cá nhân yêu cầu URL.
* Khi một URL đã được rút ngắn được cung cấp cho dịch vụ rút ngắn URL, dịch vụ rút ngắn URL sẽ tìm kiếm trong Từ điển và lấy lại liên kết gốc.

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 47. Giải thích chiến lược caching?

Caching là một kỹ thuật trong đó các đối tượng trong ứng dụng của bạn được lưu trữ trong một khu vực lưu trữ tạm thời được gọi là bộ nhớ cache. Một chiến lược caching là để xác định mối quan hệ giữa nguồn dữ liệu và hệ thống caching của bạn, và cách dữ liệu của bạn có thể được truy cập. Có nhiều chiến lược để triển khai cache nhưng mỗi chiến lược sẽ có những tác động khác nhau đến thiết kế hệ thống của bạn và hiệu suất kết quả. Trước khi thiết kế kiến trúc của bạn, thật hữu ích khi xem xét cách dữ liệu của bạn cần được truy cập để bạn có thể xác định chiến lược nào phù hợp nhất. Dưới đây, chúng tôi sẽ phân tích một số chiến lược được áp dụng nhiều nhất.

* Cache Aside
* Read Through
* Write Through
* Write Back/Behind
* Write Around

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 48. Định nghĩa SDN networking?

SDN giúp bạn chuyển đổi mạng của mình, thoát khỏi các hạn chế phần cứng và có được sự linh hoạt, an ninh, khả năng mở rộng và khả năng lập trình tốt hơn. IBM cung cấp một phương pháp tư vấn giúp bạn tạo ra mạng động và bền vững, có thể được kích hoạt bởi đám mây mà doanh nghiệp của bạn cần.
Lợi ích:

* An ninh
* Quản lý doanh nghiệp toàn diện
* Cung cấp mạng tập trung

**[Quay lại đầu trang](https://github.com/aatul/Java-Interview-Questions-Answers/blob/master/README.md#java-interview-questions-answers)**

---

### 49. Lập trình đa luồng là gì?

Java là một ngôn ngữ lập trình đa luồng có nghĩa là chúng ta có thể phát triển các chương trình đa luồng bằng Java. Một chương trình đa luồng chứa hai hoặc nhiều phần có thể chạy đồng thời và mỗi phần có thể xử lý một nhiệm vụ khác nhau cùng một lúc, tối ưu hóa việc sử dụng tài nguyên có sẵn, đặc biệt khi máy tính của bạn có nhiều CPU.

Theo định nghĩa, đa nhiệm là khi nhiều quy trình chia sẻ tài nguyên xử lý chung như CPU. Đa luồng mở rộng ý tưởng đa nhiệm vào các ứng dụng mà bạn có thể chia nhỏ các hoạt động cụ thể trong một ứng dụng duy nhất thành các thread riêng lẻ. Mỗi thread có thể chạy song song. Hệ điều hành chia sẻ thời gian xử

